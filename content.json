{"meta":{"title":"马飞的博客","subtitle":null,"description":"产品改变世界，技术驱动未来","author":"马飞","url":"http://logan62334.github.io","root":"/"},"pages":[{"title":"","date":"2019-02-26T06:39:44.794Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"baidu_verify_Ss0CClWuKM.html","permalink":"http://logan62334.github.io/baidu_verify_Ss0CClWuKM.html","excerpt":"","text":"Ss0CClWuKM"},{"title":"About","date":"2019-02-26T06:39:44.794Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"about/index.html","permalink":"http://logan62334.github.io/about/index.html","excerpt":"","text":"关于博客画家与黑客是相似的：他们都是创造者，就好像作曲家，建筑师，以及作家一样，他们的目的是创造某种美好的事物。博客内容不一定与技术相关，技术只是我们解决问题的工具。 关于作者 想做产品，却误入程序世界不小心爱上摄影的旅行家。 我的微信公众号：离岛LOGAN"},{"title":"Categories","date":"2019-02-26T06:39:44.794Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"categories/index.html","permalink":"http://logan62334.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-02-26T06:39:44.794Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"tags/index.html","permalink":"http://logan62334.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android | 自动化测试辅助服务","slug":"Android | 自动化测试辅助服务","date":"2017-12-27T22:48:52.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2017/12/27/Android | 自动化测试辅助服务/","link":"","permalink":"http://logan62334.github.io/2017/12/27/Android | 自动化测试辅助服务/","excerpt":"","text":"今天聊聊Android的自动化测试，但这里先不讨论具体的技术方案，这些放到后面章节讨论，本文主要来跟大家分享一下自动化测试过程中一定会遇到的一些问题以及针对这些问题提供的一系列辅助服务。 UI自动化测试不管是通过什么方案实现的UI自动化，录制回放也好、写自动化脚本也好，都会遇到同样的问题：在不同手机上安装被测应用时弹出的系统提示框，这部分肯定是没办法通过脚本实现的，而且存在兼容性问题：不同手机的安装流程一般是不一样的，那么怎么才能让安装这部分流程自动化呢？ 想想去年很火的抢红包插件，其实解决的问题是类似的就是检测屏幕的UI变化然后让系统自动去点击相应的控件元素，我们的主角登场了：AccessibilityService 具体实现参考：https://github.com/logan62334/Jarvis 安装好辅助应用后，点击图标会打开系统的辅助功能页面，这里会看到系统服务中已经注册好了一个叫智能安装服务的条目，打开该服务即可。 大家可以根据不同手机的安装提示进行适配，目前项目只适配了华为和小米的机型。 Monkey大家做Android稳定性测试的时候一定用过Monkey吧，但是实际跑的过程中会出现各种各样的问题，比如：关掉WIFI、关掉数据流量、锁掉屏幕等，接下来针对这些问题分析下如何解决： 针对关掉WIFI这种情况比较简单的做法就是通过起一个服务监听网络状态，一旦出现WIFI关闭的情况就自动打开当然这里涉及到权限的一些问题，只适用于root过的手机或者版本比较低的系统没有很严格的权限管理；另外一种情况就是利用部分手机可以调整快捷入口的方式将WIFI这个入口隐藏掉，还有就是可以通过遮挡住通知栏这样下拉操作就不会打开WIFI的快捷入口，数据流量也是一样的道理。 对于锁屏屏幕自动熄灭这样的情况，一种方式就是通过手机系统设置让屏幕常亮，另外一种方式就是通过PowerManager、KeyguardManager等来唤醒解锁Android设备或模拟器，具体实现方式参考：https://github.com/logan62334/Jarvis Settings另外可能在自动化测试的过程中我们希望控制系统的wifi、数据流量、动画等的状态，那么可以通过广播的形式来实现，具体方式参考：https://github.com/logan62334/Jarvis","categories":[{"name":"Android 自动化测试","slug":"Android-自动化测试","permalink":"http://logan62334.github.io/categories/Android-自动化测试/"}],"tags":[{"name":"Android 自动化测试","slug":"Android-自动化测试","permalink":"http://logan62334.github.io/tags/Android-自动化测试/"}]},{"title":"Python | 获取iOS设备信息的轻量级框架","slug":"Python | 获取iOS设备信息的轻量级框架","date":"2017-12-26T22:48:52.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/12/26/Python | 获取iOS设备信息的轻量级框架/","link":"","permalink":"http://logan62334.github.io/2017/12/26/Python | 获取iOS设备信息的轻量级框架/","excerpt":"","text":"今天接着上一篇Python | 获取Android设备信息的轻量级框架，来讲讲 如何通过Python实现一个轻量级的库来获取电脑上连接的iOS设备信息。 这个库只有一个文件，通过封装libimobiledevice命令实现，返回的是一个包含所有设备信息的标准json格式的列表方便解析，下面简单介绍一下： libimobiledevice命令封装1234567891011121314151617181920212223242526272829303132333435@staticmethoddef get_ios_devices(): devices = [] output = Shell.invoke(&apos;idevice_id -l&apos;) config_file = os.path.join(os.path.dirname(__file__), &apos;ios_mapping.json&apos;) with open(config_file, &apos;r&apos;) as f: config = json.loads(f.read()) if len(output) &gt; 0: udids = output.strip(&apos;\\n&apos;).split(&apos;\\t&apos;) for udid in udids: dic = &#123;&quot;os_type&quot;: &apos;iOS&apos;, &quot;uid&quot;: udid&#125; output = Shell.invoke(&apos;ideviceinfo -u %s -k ProductType&apos; % udid) device_type = config[output.strip(&apos;\\n&apos;)] brand = &apos;&apos; # -1表示找不到 0表示下标 if device_type.find(&quot;iPhone&quot;) != -1: brand = &apos;iPhone&apos; elif device_type.find(&quot;iPad&quot;) != -1: brand = &apos;iPad&apos; elif device_type.find(&quot;iPod&quot;) != -1: brand = &apos;iPod&apos; dic[&apos;brand&apos;] = brand dic[&apos;model&apos;] = device_type output = Shell.invoke(&apos;ideviceinfo -u %s -k ProductVersion&apos; % udid) dic[&apos;os_type&apos;] = &apos;iOS&apos; dic[&apos;os_version&apos;] = output.strip(&apos;\\n&apos;) dic[&apos;rom_version&apos;] = output.strip(&apos;\\n&apos;) output = Shell.invoke(&apos;idevicename -u %s&apos; % udid) dic[&apos;device_name&apos;] = output.strip(&apos;\\n&apos;) devices.append(dic) return devices 设备信息数据结构1234567891011[ &#123; &quot;uid&quot;: &quot;xxxxxxxxxxxxxx1f8a4dcfaac1fd01&quot;, &quot;rom_version&quot;: &quot;11.0.3&quot;, &quot;brand&quot;: &quot;iPhone&quot;, &quot;device_name&quot;: &quot;马飞的 iPhone&quot;, &quot;os_version&quot;: &quot;11.0.3&quot;, &quot;model&quot;: &quot;iPhone6s&quot;, &quot;os_type&quot;: &quot;iOS&quot; &#125;] 注：有时候会报Couldn’t connect to lockdown这样的错误，执行下面命令即可：1234$ brew uninstall ideviceinstaller$ brew uninstall libimobiledevice$ brew install --HEAD libimobiledevice$ brew install ideviceinstaller 这个库我已经上传到Pypi仓库，源码在github：https://github.com/logan62334/python-apptoolkit，点击阅读原文可以访问","categories":[{"name":"Python iOS","slug":"Python-iOS","permalink":"http://logan62334.github.io/categories/Python-iOS/"}],"tags":[{"name":"Python iOS","slug":"Python-iOS","permalink":"http://logan62334.github.io/tags/Python-iOS/"}]},{"title":"Android | 图解外部存储和内部存储","slug":"Android | 图解外部存储和内部存储","date":"2017-12-19T22:53:33.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2017/12/19/Android | 图解外部存储和内部存储/","link":"","permalink":"http://logan62334.github.io/2017/12/19/Android | 图解外部存储和内部存储/","excerpt":"","text":"存储概述Android中根据数据是否为应用私有、是否需要给外部应用暴露以及数据的大小可以有以下几种选择： Shared Preferences 内部存储 外部存储 本地数据库存储 通过网络在服务器端数据库存储 今天我们重点解释下内外部存储到底是什么有哪些区别，请看下图： 内外部存储的区别 按照内外部存储：带External字眼则一定是外部存储的方法，如 getExternalFilesDir() ，外部存储需要运行时权限； 按照公有私有性质：公有文件是Environment调用函数，而私有文件（包括内部私有与外部私有）是Context调用函数，公有文件不会随着app卸载而删除而私有则会，私有文件不会被Media Scanner扫描到。","categories":[{"name":"Android","slug":"Android","permalink":"http://logan62334.github.io/categories/Android/"}],"tags":[{"name":"Android 存储","slug":"Android-存储","permalink":"http://logan62334.github.io/tags/Android-存储/"}]},{"title":"Python | 获取Android设备信息的轻量级框架","slug":"Python | 获取Android设备信息的轻量级框架","date":"2017-12-17T22:48:52.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/12/17/Python | 获取Android设备信息的轻量级框架/","link":"","permalink":"http://logan62334.github.io/2017/12/17/Python | 获取Android设备信息的轻量级框架/","excerpt":"","text":"今天跟大家分享一下，如何通过Python实现一个轻量级的库来获取电脑上连接的Android设备信息，为什么说轻量呢因为整个库也就4KB，相比其他诸如Appetizer这样动辄就8MB多的库要轻很多，而且也基本满足项目中的需求。 这个库只有一个文件，通过封装Android的ADB命令实现，返回的是一个包含所有设备信息的标准json格式的列表方便解析，下面简单介绍一下： 检查环境变量12345678910# 判断是否设置环境变量ANDROID_HOMEif &quot;ANDROID_HOME&quot; in os.environ: command = os.path.join( os.environ[&quot;ANDROID_HOME&quot;], &quot;platform-tools&quot;, &quot;adb&quot;)else: raise EnvironmentError( &quot;Adb not found in $ANDROID_HOME path: %s.&quot; % os.environ[&quot;ANDROID_HOME&quot;]) 命令执行123456789class Shell: def __init__(self): pass @staticmethod def invoke(cmd): output, errors = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate() o = output.decode(&quot;utf-8&quot;) return o ADB命令封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class ADB(object): &quot;&quot;&quot; 参数: device_id &quot;&quot;&quot; def __init__(self, device_id=&quot;&quot;): if device_id == &quot;&quot;: self.device_id = &quot;&quot; else: self.device_id = &quot;-s %s&quot; % device_id def adb(self, args): cmd = &quot;%s %s %s&quot; % (command, self.device_id, str(args)) return Shell.invoke(cmd) def shell(self, args): cmd = &quot;%s %s shell %s&quot; % (command, self.device_id, str(args),) return Shell.invoke(cmd) def get_device_state(self): &quot;&quot;&quot; 获取设备状态： offline | bootloader | device &quot;&quot;&quot; return self.adb(&quot;get-state&quot;).stdout.read().strip() def get_device_id(self): &quot;&quot;&quot; 获取设备id号，return serialNo &quot;&quot;&quot; return self.adb(&quot;get-serialno&quot;).stdout.read().strip() def get_android_version(self): &quot;&quot;&quot; 获取设备中的Android版本号，如4.2.2 &quot;&quot;&quot; return self.shell( &quot;getprop ro.build.version.release&quot;).strip() def get_sdk_version(self): &quot;&quot;&quot; 获取设备SDK版本号，如：24 &quot;&quot;&quot; return self.shell(&quot;getprop ro.build.version.sdk&quot;).strip() def get_product_brand(self): &quot;&quot;&quot; 获取设备品牌，如：HUAWEI &quot;&quot;&quot; return self.shell(&quot;getprop ro.product.brand&quot;).strip() def get_product_model(self): &quot;&quot;&quot; 获取设备型号，如：MHA-AL00 &quot;&quot;&quot; return self.shell(&quot;getprop ro.product.model&quot;).strip() def get_product_rom(self): &quot;&quot;&quot; 获取设备ROM名，如：MHA-AL00C00B213 &quot;&quot;&quot; return self.shell(&quot;getprop ro.build.display.id&quot;).strip() 设备信息获取123456789101112131415161718192021222324252627282930class DeviceInfo: def __init__(self, uid, os_type, os_version, sdk_version, brand, model, rom_version): self.uid = uid self.os_type = os_type self.os_version = os_version self.sdk_version = sdk_version self.brand = brand self.model = model self.rom_version = rom_versionclass Device: def __init__(self): pass @staticmethod def get_android_devices(): android_devices_list = [] android_devices_infos = [] for device in Shell.invoke(&apos;adb devices&apos;).splitlines(): if &apos;device&apos; in device and &apos;devices&apos; not in device: device = device.split(&apos;\\t&apos;)[0] android_devices_list.append(device) for device_uid in android_devices_list: device_info = DeviceInfo(device_uid, &quot;Android&quot;, ADB(device_uid).get_android_version(), ADB(device_uid).get_sdk_version(), ADB(device_uid).get_product_brand(), ADB(device_uid).get_product_model(), ADB(device_uid).get_product_rom()) android_devices_infos.append(device_info.__dict__) return android_devices_infos 设备信息数据结构1234567891011121314151617181920[ &#123; &quot;uid&quot;: &quot;BY2WKN1519078327&quot;, &quot;rom_version&quot;: &quot;Che2-UL00 V100R001CHNC00B287&quot;, &quot;brand&quot;: &quot;Honor&quot;, &quot;os_version&quot;: &quot;4.4.2&quot;, &quot;sdk_version&quot;: &quot;19&quot;, &quot;os_type&quot;: &quot;Android&quot;, &quot;model&quot;: &quot;Che2-UL00&quot; &#125;, &#123; &quot;uid&quot;: &quot;GWY0217414001213&quot;, &quot;rom_version&quot;: &quot;MHA-AL00C00B213&quot;, &quot;brand&quot;: &quot;HUAWEI&quot;, &quot;os_version&quot;: &quot;7.0&quot;, &quot;sdk_version&quot;: &quot;24&quot;, &quot;os_type&quot;: &quot;Android&quot;, &quot;model&quot;: &quot;MHA-AL00&quot; &#125;] 安装&amp;更新1pip install -U apptoolkit 这个库我已经上传到Pypi仓库，源码在github：https://github.com/logan62334/python-apptoolkit","categories":[{"name":"Python Android","slug":"Python-Android","permalink":"http://logan62334.github.io/categories/Python-Android/"}],"tags":[{"name":"Python Android","slug":"Python-Android","permalink":"http://logan62334.github.io/tags/Python-Android/"}]},{"title":"Python | 一个快速实现CLI 应用程序的脚手架","slug":"Python | 一个快速实现CLI 应用程序的脚手架","date":"2017-12-02T22:48:52.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/12/02/Python | 一个快速实现CLI 应用程序的脚手架/","link":"","permalink":"http://logan62334.github.io/2017/12/02/Python | 一个快速实现CLI 应用程序的脚手架/","excerpt":"","text":"今天跟大家分享一下如何快速实现一个Python CLI应用程序的脚手架，之所以会做这个是因为当时需要做一个运维的小工具希望用命令行的方式来使用，但是搜遍网上很多资料都没有系统讲解从开发、集成、发布、文档等一系列流程的文章。 工程结构 如上图，这就是一个比较规范的Python CLI应用项目了，下面一一讲下各文件的用途： 项目文档 这里我们用Sphinx来实现文档的自动生成，当然你要首先通过markdown和rst文件定义好文档的内容，然后进入docs目录执行 make html命令就可以在_build目录下生成对应的静态文件，如下图： 具体Sphinx如何使用以及配置后面会单独文章讲解 主工程 这里讲几个需要注意的地方1、日志的配置：这里可以全局设置日志的一些输出级别和格式化方式 2、cli文件这里通过click库来实现 3、二进制文件打包 如上图，有时候我们的工程中会包含二进制文件，也就是非Python代码的文件，这时候如果还是像往常一样打包发布，安装的时候会发现无法找到此文件，所以需要在根目录的MANIFEST.in文件中加入 脚本 如下图，这里的make-release文件主要是用来自动控制版本的，如下图，通过Git 的提交记录了来作为项目的唯一版本号标识，再对init文件进行重新写入达到持续集成时版本号自增的目的。 单元测试 test文件夹中存放的就是项目的单元测试文件了，这里就不细展开讲了，后面会具体讲讲如何跟Jenkins集成实现静态代码检查 setup 最重要的就是setup.py这个文件了，项目最后打包发布到pypi仓库主要的配置信息都在这里了，如下图： 这个脚手架的项目地址：https://github.com/logan62334/python-cli-template项目会持续更新，可以点击阅读原文访问","categories":[{"name":"Python","slug":"Python","permalink":"http://logan62334.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://logan62334.github.io/tags/Python/"}]},{"title":"DevOps | 实现命令行交互自动化","slug":"DevOps | 实现命令行交互自动化","date":"2017-12-01T22:48:52.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/12/01/DevOps | 实现命令行交互自动化/","link":"","permalink":"http://logan62334.github.io/2017/12/01/DevOps | 实现命令行交互自动化/","excerpt":"","text":"嗨呀，好久没有更新了，最近几个月一直忙着部门内质量平台的建设，因为是新成立的小组所以很多东西都是从零开始做，这期间做了很多跟自动化、代码质量和工程效率相关的事情，接下来一段时间会慢慢把其中一些有趣的东西整理出来跟大家分享。 今天先来介绍一个Python中用来实现命令行交互自动化的模块，之所以会有这样的需求是因为我们希望把一些繁琐的命令行交互过程给透明化这样对用户来说会友好很多降低使用成本，如下图： 这里是一个典型的需要用户交互的命令行操作，当执行命令后会提示用户输入测试脚本文件名，回车后会再提示用户输入app的路径，如何让这一过程自动化呢？ 就是它了shutit，其实还有个工具 pexpect 但是我试了好多次都没能达到想要的效果，而且网上大部分给出的解决方案也都是针对ssh登录自动化的，对于一个普遍的交互式命令行却不支持，当然也可能是我使用姿势不对？如果大家有通过pexpect实现的还请跟我交流哈","categories":[{"name":"DevOps","slug":"DevOps","permalink":"http://logan62334.github.io/categories/DevOps/"}],"tags":[{"name":"DevOps Python","slug":"DevOps-Python","permalink":"http://logan62334.github.io/tags/DevOps-Python/"}]},{"title":"Macaca 面向多端的自动化测试解决方案","slug":"Macaca 面向多端的自动化测试解决方案","date":"2017-06-22T22:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/06/22/Macaca 面向多端的自动化测试解决方案/","link":"","permalink":"http://logan62334.github.io/2017/06/22/Macaca 面向多端的自动化测试解决方案/","excerpt":"","text":"背景 对于基于 UI 的功能测试的需求其实一直存在，理由其实很简单，不想一直让人去做重复机械的事情，而且可靠性完全是靠人力的堆积产生。然而目前部门的功能测试工作依然主要是依靠人工来完成，从我们公司的实践来看我觉得有几个方面的影响因素： 客户端APP已经实现模块化开发，而且外卖平台移动端的开发迭代流程正在进行改造，目标是从固定每三周一个迭代改造为每周一个发布窗口，版本迭代的提速，设备的碎片化，都给测试工作带来巨大的挑战。由于版本迭代周期越来越短，而且UI变动比较频繁，因此测试编写测试代码的积极性不是很高，同时由于测试代码的可重复利用性差，导致测试脚本的编写成本和维护成本偏高 。部分测试人员的编码能力不是很强。由于大部分测试人员可能并没有过多的开发经验，所以在编写测试代码时并不能很顺畅的完成自己想要的效果，这样也会导致测试代码项目的推广阻力会比较大。 如何在有限的时间内，追求尽可能高的产品质量？录放平台是我们推出的解决方案。它支持本地化UI脚本录制，集中式脚本管理，分布式脚本执行。业务测试只要开启我们的服务，就可以在业务测试的过程中，自动生成对Android、iOS和Web页面的自动化脚本，而自动化脚本在批量设备上的回放，可以极大提高关键路径的覆盖率，提升兼容性测试的效率，从而可以把业务测试从冗长重复的步骤中解放出来，把精力放到边界，异常等可以给我们产品带来更多提升的地方。 通过不断地寻找，不断地对比，最终我们将目标聚焦在阿里巴巴开源解决方案Macaca上。 简介 Macaca是一套完整的自动化测试解决方案，它的三个特性对我们极具吸引力： 1、周边工具支持（Reliable、app-inspector、UI-Recorder等）2、它是一个轻量化的开源项目3、社区活跃，中文文档丰富4、支持JS、Python、Java编写自动化脚本5、API比较统一 技术栈 在落地Macaca之前，需要先部署下列技术栈：1、Node.js用于部署Macaca2、Docker用于容器化Macaca的部署环境3、Gitlab用于存储代码和测试用例4、Slack用于团队的沟通协调5、Python用于部署本地Agent 使用流程 业务测试人员通过在本地录制好测试脚本，然后上传到脚本管理平台，这些测试脚本将会根据业务模块和版本分类管理。使用者在自己的电脑上安装Agent，然后连接测试设备，Agent会将本机的ip、port和设备信息上传注册到录放平台。 新建一个task执行脚本回放操作，可以指定在哪些机器上回放也可以推送到STF手机管理平台批量回放，测试用例运行之后，会有两种情况发生：如果成功，则可以直接查看生成报告；否则会通过Slack或邮件通知开发人员测试失败，重新修改代码。 另外Macaca也提供了相应的分布式持续集成框架Reliable来进行任务管理。 Reliable 下图是Reliable的界面，通过Reliable用户可以查看测试用例和测试结果；并且Reliable天生与Macaca无缝衔接。 Inspector Macaca中还提供了Inspector工具供用户直观、方便查找到想要选中的元素。图中右侧一栏提供的是XPS、ID、Name数据，用户通过Inspector工具寻找目标界面的元素。 Debug 我们选择Visual Studio Code作为常用的IDE因为它能够轻量地、方便地支持使用者Debug，用户可以根据自己喜好选择相应地调试工具。 UI Recorder 下图是简单的登录测试用例：输入用户名和密码，然后点击登录按钮。UI-Recorder脚本录制工具可以快速的通过录制得到脚本，方便新手入门。 测试报告 最终的测试结果需要与饿了么的质量平台对接（Macaca产生的测试报告、测试结果数据在导入饿了么质量平台前需要进行数据转换），形成完整的测试流程。 上面总结了一下自己在调研并选择UI自动化框架中的一些思考，希望能给处于UI自动化调研初期的同学们一些帮助，其中很多选择是出于自身业务的需要，仅供参考，希望大家能结合自身业务的需要，找到适合自己的UI自动化框架。另外如果有对此框架感兴趣的同学欢迎一起学习交流。","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://logan62334.github.io/categories/自动化测试/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://logan62334.github.io/tags/自动化测试/"}]},{"title":"配置Android项目 - 版本名称和代码","slug":"配置Android项目 - 版本名称和代码","date":"2017-03-22T11:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/03/22/配置Android项目 - 版本名称和代码/","link":"","permalink":"http://logan62334.github.io/2017/03/22/配置Android项目 - 版本名称和代码/","excerpt":"","text":"Version Name &amp; Code开发人员通常给android versionName＆versionCode使用一些硬编码值。 这种方法有几个缺点： 你永远不知道哪个提交代表一个特定的版本。 每当你增加versionCode和更改versionName，你必须修改build.gradle文件。 如果你使用git作为源代码控制系统，它也可以帮助你生成android versionName＆versionCode。常见的做法是使用git标签来指示新版本的发布。 Version Name对于versionName，我们可以使用git describe命令。 a.该命令查找从提交开始可访问的最近的标记。 b.如果标记指向提交，则只显示标记。 c.否则，它将标记名称与标记对象顶部的附加提交数以及最近提交的缩写对象名称作为后缀。 Example (a-b) 使用tag1.0标记特定提交 签出此提交 调用git describe -tags 输出：1.0 正如你看到的，如果你使用一些标签在一个HEAD提交上调用git describe，它会输出这个标签。 Example (a-c) 标记tag为1.0的提交 再添加两个提交 调用git describe -tags 输出：1.0-2-gdca226a 使用git提交哈希“1.0-2-gdca226a”，我们可以很容易地找出从哪个特定的提交构建。 Version Code对于versionCode，我们可以使用标签的总数。因为每个git标签指示一些版本，下一版本的versionCode将总是大于previous。 在上面的示例中，我们有3个标签。这个值将用于我们的versionCode。 但是我们不会为每个中间版本创建一个git标签，因此对于dev build我们可以使用HEAD提交的时间戳。 在上面的示例中，HEAD提交的时间戳等于1484407970（自UNIX纪元1970年1月1日00:00:00 UTC以来的秒数）。这个值将用于我们的versionCode。如果你想将它转换为人类可读的日期使用currentmillis.com网站。在我们的情况下，它是Sat 1月14日2017 15:32:50 UTC。 Groovy way to use git要使用git我建议使用一个称为grgit的库。创建具有以下内容的script-git-version.gradle文件： 将其应用于您的build.gradle文件： 要检查version name 和 code是否正确生成调用gradle任务./gradlew printVersion它给出类似的输出： 最后在build.gradle文件中使用gitVersionName，gitVersionCode和gitVersionCodeTime变量。 运行项目并验证应用版本。 这种方法的好处： 不需要修改build.gradle文件 - versionCode和versionName是自动生成的。 你可以很容易地找出从哪个提交生成。 注：你可以尝试其他的方式来标记版本名：包括分支名称，时间戳等。","categories":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/categories/Android架构/"}],"tags":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/tags/Android架构/"}]},{"title":"配置Android项目 - 静态代码分析工具","slug":"配置Android项目 - 静态代码分析工具","date":"2017-03-21T11:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/03/21/配置Android项目 - 静态代码分析工具/","link":"","permalink":"http://logan62334.github.io/2017/03/21/配置Android项目 - 静态代码分析工具/","excerpt":"","text":"静态代码分析工具静态代码分析工具 - 分析代码而不执行它。通常用于发现错误或确保符合编码指南。有助于保持你的代码健康，并保持代码质量。 在Android上，最流行的代码分析工具是： Lint PMD Findbugs 我通常将静态代码分析脚本和相关文件保存在单独的文件夹中。 Lint lint工具检查你的Android项目源文件是否存在潜在错误，并针对正确性，安全性，性能，可用性，可访问性和国际化进行优化改进。 配置添加lint到你的android项目创建script-lint.gradle文件。 重要的lint选项： lintConfig —lint规则集的路径（可以用来配置压制警告）。 htmlOutput —html报告生成的地方。 将script-lint.gradle导入到build.gradle文件。 测试重新构建你的项目，然后使用./gradlew lint命令运行lint。如果它发现一些问题，你会看到类似下面的输出。 当你打开lint.html报告文件时，你将看到问题列表描述，和如何解决它们的建议。 如果你想忽略此问题，请将以下规则添加到rules-lint.xml文件中。 注意：还有其他方法可以压制lint警告。有关lint的更多信息，请访问官方网站。 Findbugs 静态代码分析工具，用于分析Java字节码并检测各种各样的问题。 配置要添加findbug到你的android项目需要创建script-findbugs.gradle文件。 重要的findbugs选项： excludeFilter —findbugs规则集文件所在的路径，你可以在其中压制问题。 classes — 生成的类的路径（如果你有多个flavor，路径由flavor名称组成，在当前情况下为“dev”）。 source —源代码的路径 html.destination —html报告生成的路径 将script-findbugs.gradle导入到build.gradle文件。 测试为了测试，我们将创建以下方法。 重新构建你的项目，然后运行findbugs ./gradlew findbugs命令。如果它发现一些问题，你会看到类似下面的输出。 当你打开findbugs.html报告文件，你将看到问题列表与说明和如何解决它们的建议。 如果你想忽略此问题，请将以下规则添加到rules-findbugs.xml文件中。 注意：还有其他方法去压制findbugs警告。有关findbugs的更多信息，请访问官方网站。 PMD PMD是一个源代码分析器。它发现常见的编程缺陷，如未使用的变量，空catch块，不必要的对象创建等等。 配置要添加pmd到你的android项目那么需要创建script-pmd.gradle文件。 重要的pmd选项： ruleSetFiles —pmd规则集文件的路径，你可以在其中压制问题并定义要跟踪的问题。 source —源代码的路径 html.destination —html报告生成的路径 将脚本script-pmd.gradle导入到build.gradle文件。 测试为了测试，我们将创建以下方法。 重新构建你的项目，然后使用./gradlew pmd命令运行pmd。如果它发现一些问题，你会看到类似下面的输出。 当你打开pmd.html报告文件，你将看到问题列表与说明和如何解决它们的建议。 如果你想忽略此问题，请将以下规则添加到rules-pmd.xml文件中。 注意：还有其他方法压制pmd警告。有关pmd的更多信息，请访问官方网站。","categories":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/categories/Android架构/"}],"tags":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/tags/Android架构/"}]},{"title":"配置Android项目 - 一些重要的事情","slug":"配置Android项目—一些重要的事情","date":"2017-03-20T11:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/03/20/配置Android项目—一些重要的事情/","link":"","permalink":"http://logan62334.github.io/2017/03/20/配置Android项目—一些重要的事情/","excerpt":"","text":"gitignore当你在Android Studio中创建一个新的Android项目时，它已经生成了gitignore文件，但通常它不包含所有必要的规则。 为了快速生成和下载gitignore文件，我建议您使用gitignore.io网站。只需输入必要的关键字，如 — Android，Intellij并点击生成按钮。 在模板项目中查看gitignore文件。 tools folder如果你有一些第三方脚本，规则集或其他与您的项目相关的文件不要只是简单的把它们放在根目录 —它会造成混乱。（特别是对于那些使用Project视图，而不是Android视图） 尝试创建一个文件夹（例如tools），并将所有这些文件放入此文件夹。 通常我在那里放一些自定义的gradle脚本文件，proguard和静态代码分析工具的规则，如pmd，findbugs，lint。 在模板项目中查看 tools文件夹。 flavorsFlavours用于创建具有不同设置的构建。在大多数情况下，我会立即设置两种flavors — dev和prod： applicationId versionCode / versionName server endpoints google services keys … 在模板项目中查看 productFlavors。 keystorekeystore是一个二进制文件，其中包含一个或多个用于签署应用程序的私钥。 当从IDE运行或调试项目时，Android Studio会使用Android SDK工具生成的调试证书自动为您的APK签名。 使用本地调试keystore时有几个问题： 到期日365天 从多台计算机安装应用程序需要先卸载 google服务需要密钥库SHA-1指纹 这就是为什么我通常生成调试密钥库并提交到版本控制系统。 在模板项目中查看 signingConfigs。 proguardAndroid proguard用来做三件事： 压缩未使用的代码 — 帮助你不超出64k限制 优化代码和apk 混淆代码 — 使你的APK难以做逆向工程 问题是混淆和代码优化显着增加了编译时间，使调试更困难。 这就是为什么最好对发布和调试版本使用不同的proguard规则： rules-proguard.pro rules-proguard-debug.pro 用于调试构建的Proguard规则必须具有以下行以强制proguard忽略警告，跳过代码混淆和优化： 对于发布版本，设置proguard规则将会更加困难，因为几乎每个库都有自己的特定规则。幸运的是，有一个开源代码库 — android-proguard-snippets，它包含所有主要库的proguard规则。 在模板项目中查看 rules-proguard.pro和rules-proguard-debug.pro。 strict modeAndroid StrictMode可帮助您检测不同类型的问题： 可关闭对象没关闭 在主线程中读写文件或者访问网络 uri 暴露 … 每当检测到这样的问题，它可以显示适当的日志或应用程序崩溃，具体取决于你的配置。 我建议你只在调试的时候打开它并且使用detectAll方法来检测所有类型的问题。 这里是当你忘记关闭SQLiteCursor的日志的例子： 在模板代码中查看StrictMode。","categories":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/categories/Android架构/"}],"tags":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/tags/Android架构/"}]},{"title":"Model-View-Presenter:Android指南","slug":"Model-View-Presenter:Android指南","date":"2017-03-10T11:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2017/03/10/Model-View-Presenter:Android指南/","link":"","permalink":"http://logan62334.github.io/2017/03/10/Model-View-Presenter:Android指南/","excerpt":"","text":"原文地址：https://medium.com/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf#.nqgbpr2bj 网上有很多关于MVP架构的文章和示例，并且有很多不同的实现。但开发者社区仍不断努力，想以尽可能最好的方式将此模式应用在Android上。 如果你决定采用这种模式，你正在做一个架构选择，你必须知道你的代码库将改变，以及你新的功能也要用新的方法来开发。另外你需要面对常见的Android问题如Activity生命周期，然后你还应该问问自己下面这些问题： 我应该保存presenter的状态吗？ 我应该将presenter做持久化处理吗？ presenter需要有生命周期吗？ 在本文中，我将提供一系列准则或最佳做法，以便： 解决采用这个架构遇到的最常见问题（至少是一些我遇到过的） 发挥这个架构的最大优势 首先，让我们先解释一下这个模式： Model：它是负责管理数据的接口。模型的职责包括使用API，缓存数据，管理数据库等。该模型还可以是与负责这些职责的其他模块通信的接口。例如，如果你使用Repository模式，则模型可以是Repository。如果你使用的是Clean架构，那么Model可以是一个Interactor。 Presenter：presenter是model和view的中间人。你的所有业务逻辑都应该放在这里面。presenter负责查询model和更新view，对更新模型的用户交互作出反应。 View：它只负责以presenter定义的方式来显示数据。view可以被Activities、 Fragments、任何Android widget或者其他一些像显示ProgressBar、更新TextView、填充RecyclerView等等可执行操作的视图。 下面是以我的观点列出的一些指南，你可能不会全部赞同，不过我会试着解释为什么这么做。 1. 让View变得被动和无知Android中最大的一个问题就是view（Activities、Fragments等）不是那么容易被测试因为Android框架很复杂。为了解决这个问题，你需要实现Passive View模式。这种实现方式通过利用一个controller来减少view的业务行为，在我们的例子中，这个controller是presenter。这种方式显著的提高的代码的可测试性。 例如，如果你有一个username/password的表单和一个提交按钮，你不需要在view中写验证逻辑而是将它写在presenter中。你的view只管接受用户名和密码的输入然后将他们传递给presenter即可。 2. 使presenter与框架无关为了提高代码的可测试性，那么就要确保presenter不能依赖Android类文件。presenter用纯java代码实现的两个理由：首先你要将具体的实现抽象到presenter中，这样的话你就可以写不依赖于设备的测试代码了（甚至都不需要Robolectric），可以快速的在你的本地JVM中运行而不需要模拟器。 如果我需要用到Context呢? 那么就不要用它。在这种情况下，你应该问一下自己为什么需要context呢。我猜你可能想要存储数据或者获取资源。但是你不需要在presenter中做这些：你可以在view中获取资源，在model中存储数据。这里只是两个简单的例子，不过我敢打赌大多数情况下都是因为类的职责不明确导致的。 顺便说一下，依赖倒置原则可以帮助你在这种情况下解耦。 3. 写一个contract类来描述View和Presenter之间的交互当你准备开始写一个新功能时，第一步最好先写一个contract类。contract描述了view和presenter之间的交互，它帮助你以更干净的方式设计交互。 我喜欢用Google在 Android Architecture repository中建议的解决方案：这个contract接口类中包含两个接口一个是view另一个是presenter。 让我们举个例子。 123456789101112131415161718192021public interface SearchRepositoriesContract &#123; interface View &#123; void addResults(List&lt;Repository&gt; repos); void clearResults(); void showContentLoading(); void hideContentLoading(); void showListLoading(); void hideListLoading(); void showContentError(); void hideContentError(); void showListError(); void showEmptyResultsView(); void hideEmptyResultsView(); &#125; interface Presenter extends BasePresenter&lt;View&gt; &#123; void load(); void loadMore(); void queryChanged(String query); void repositoryClick(Repository repo); &#125;&#125; 看到这个方法的名字，你应该就明白这个例子中的contract是干什么的了吧。 如果你还不知道，那一定是你的问题哈哈。 在这个例子中你可以看到view中定义的方法非常简单而且不包含任何逻辑。 The View contract正如我之前说过的，view接口是要被Activity或者Fragment实现的。presenter必须依赖于view接口而不是直接依赖于Activity：通过这种方式，你可以将presenter从视图实现解耦，遵循SOLID原则的D：“依赖抽象，不要依赖具体实现）。 我们不需要更改presenter中的一行代码就可以替换具体的视图。因此我们可以非常容易的通过创建一个mock view来进行单元测试。 The presenter contract 等等，我们真的需要一个Presenter接口吗？ 事实上不需要，但我认为还是要的。 关于这个话题有两种不同的思想流派。 一些人认为应该写一个Presenter接口因为你要将具体的presenter和view解耦。 然而另外一些开发者认为你在抽象的东西已经是一个抽象的了所以不需要再写一个接口了。另外不管怎么样，有了一个接口后可以帮你方便的写mock presenter，不过如果你采用了Mockito这样的工具类那么你就不需要接口了。 我个人还是喜欢写这么一个Presenter接口的，下面是两个简单的理由： 我不是去为presenter写一个接口而是写一个Contract类来描述view和presenter之间的交互。 写这么个接口并不费什么力。 我已经这么写超过一年了甚至更长，至今没有发现什么问题。 4. 定义一个名称方便区分责任presenter通常有两种类型的方法： Actions（e.g: load()）：presenter的一些行为操作。 User events（e.g:queryChanged(…)）：用户触发的操作比如在搜索框中键入字符或者是点击列表中的某个选项。 你定义的action越多那么view中的逻辑也就越多。 当用户滚动到列表的结尾时将调用loadMore()方法，然后presenter加载另外一页的结果。这意味着当用户滚动到结尾时，view知道必须加载新页面。我可以命名方法onScrolledToEnd（）让具体的presenter处理具体做什么。 我想说的是，在“contract设计”阶段，你必须定义好每个用户事件，相应的action是什么，逻辑应该属于谁。 5. 不要在Presenter接口中创建Activity-lifecycle-style回调我使用这个标题的意思是presenter不应该有像onCreate（…），onStart（），onResume（）等方法原因如下： 如果这么做了的话presenter将会和Activity产生耦合。如果我想用一个Fragment替换Activity怎么办？我什么时候应该调用presenter.onCreate（state）方法？在fragment的onCreate(…)、onCreateView(…)还是onViewCreated(…)中？如果我使用自定义view怎么办？ presenter不应该有这么复杂的生命周期。事实上，主要的Android组件都是以这种方式设计的，但并不意味着你必须也这么做。如果你有机会可以简化的话那就简化它吧。 6. Presenter和view有1对1的关系如果没有view的话presenter就没有意义了。presenter随着view一起被创建也随着view一起被销毁。一个presenter管理一个view。 你可以通过多种方式处理presenter中view的依赖。一种方式是在presenter接口中提供像attach(View view)和detach()的方法就像之前例子中展示的那样。不过这样做有一个问题就是你需要注意view是否为null，每次presenter用到它的时候都要检查一下是否为null。这点确实有点烦…… 我说了presenter和view是一对一的关系。我们可以利用这一点，实际上具体的presenter可以将view实例作为构造函数的参数传入。顺便说一句，你可能需要一个方法来订阅presenter的一些事件。所以我建议定义一个方法start（）（或类似的方法）来运行Presenter中的业务。 关于detach()呢？ 如果你有一个叫start（）的方法，那么你可能至少还需要一个来释放依赖的方法。既然我们定义订阅presenter一些事件的方法叫start（），那么另一个方法就叫stop（）吧。 1234public interface BasePresenter&lt;V&gt; &#123; void attach(V view); void detach();&#125; 1234public interface BasePresesnter &#123; void start(); void stop();&#125; 7. 不要在presenter中保存状态我的想着是要用Bundle来保存。但考虑到上面的第二条准则就不能这么做了。你不能将数据序列化到Bundle中，因为这样的话presenter就与Android类耦合了。 我说presenter应该是无状态的，但其实也不然。在我之前描述的例子中，presenter应该至少具有页码/偏移量之类的状态。 8. 不要持久化presenter我不喜欢这种方式主要是因为我认为presenter不是我们应该持久化的，要清楚它不是一个数据类。 一些建议提供了一种在配置发生改变的时候通过恢复fragments或者 Loaders的方式记住presenter的状态。我不认为这是最好的解决方案。通过这种方式presenter可以在方向发生变化恢复，但是当Android杀死了进程并销毁Activity，后者将与新的presenter一起重新创建。因此，该解决方案仅解决了一半的问题。 9. 为Model提供缓存以恢复视图状态在我看来，解决“恢复状态”问题需要一些应用架构的知识。基本上，作者建议使用类似Repository或任何旨在管理数据的接口来缓存网络结果，范围限定于应用程序而不是Activity。 这个接口只是一个更聪明的Model。后者应至少提供磁盘缓存策略和可能的内存缓存。这样的话，即使进程被杀，presenter也可以使用磁盘缓存恢复视图状态。 view应该只关心必要的请求参数以恢复状态。例如，在我们的示例中，我们只需要保存查询。 现在，你有两个选择： 你在model层中抽象这个行为，当presenter调用repository.get（params）时，如果页面已经在缓存中，数据源只返回它，否则再调用API。 在contract中的presenter添加一个方法来恢复视图状态。restore（params），loadFromCache（params）或reload（params）这些是描述相同动作的不同名称你可以随便选一个。 结论以上是我对应用于Android的Model-View-Presenter架构的看法，希望通过不断的尝试可以找到最佳实践。","categories":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/categories/Android架构/"}],"tags":[{"name":"Android架构","slug":"Android架构","permalink":"http://logan62334.github.io/tags/Android架构/"}]},{"title":"和无序说再见","slug":"和无序说再见","date":"2016-10-13T09:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/10/13/和无序说再见/","link":"","permalink":"http://logan62334.github.io/2016/10/13/和无序说再见/","excerpt":"","text":"不要给信息归档，用的时候搜索就行了 先来看看我们日常工作生活中经常会做的文件整理吧。为了让生活更有序，因此我们都学会了如何让资料文件归档。毫无疑问，这样做是有意义的。如果不能按照某种符合逻辑的方式存放自己收到的文件或者信函，那么当你查找需要用到的东西时，就得到处翻检。而往往我们都会通过文件柜的形式去完成这样的事情（特别是传统行业的从业者）。 但是，使用这种文件柜的组织模式既没有考虑我们大脑的自身限制，也没有充分利用科学技术的新发展。 举例来说，公司在入职的时候给你发了一份关于费用报销及各项福利的说明文件。等你下次需要用到的时候就可以参考这些规定执行，以便填写正确的报销单据或者申请享受应有的福利。可是如果下次用到是几个月以后的事，你会怎么办？在此期间，你该怎么归档这份跨部门的文件呢？ 在这个问题上，大部分人的做法可能会如出一辙。你极有可能会把这个说明文件装进一个文件夹，贴上写有“福利待遇”之类字样的便签然后放进专门存放公司文件的抽屉中，可是，你怎么记得这个抽屉就是存放公司福利政策文件的地方？ 或许你也可能把相应的电子文档放到个人电脑的某个磁盘的目录下。即便如此，还是会有同样的问题：以后你能记得自己把这份文件放在这个目录下了吗？ 也许你会未雨绸缪，以防忘记这份文件放在哪，而把它复制（复印）好多份放在不同的目录下（不同的抽屉中），例如：桌面也放一份。尽管需要执行多次文档归类的操作，而且也会多占用几个字节的磁盘空间（加剧森林的砍伐），不过这种策略短期来看还是行之有效的。 时至今日，“云”已经开始变得像自来水一样慢慢的走进了大众的生活，诸如电子邮件、电子日历、文件备份、资料共享、云盘之类的服务都属于云计算的范畴。人们不必要把信息存放在个人电脑的固定硬盘或者移动存储设备上，而是可以利用上面的诸多服务，在互联网上存放所有的信息。这意味着你可以在任何一台联网的计算机或者其他设备（比如装有浏览器的手机、PAD）上访问和使用自己的信息。你的信息存放在一个地方而你可以通过很多种方式获取它，这样的话，即便你的电脑磁盘损坏或者手机中毒导致文件不可用，你也不用担心自己的数据会丢失。 只要能联网，你就可以使用绝大多数的云服务。在这些海量云服务中，我个人比较喜欢的是Google的免费Gmail、Google Drive（有15G空间）、Google Doc、Google Photo（可以上传无限张压缩无损照片）。 回到上面的例子，你完全可以把这份文件通过Gmail发给自己或者上传到Google Drive。这样的话，在你需要的时候只需要在Gmail或者Google Drive中搜索一下即可。另外如果你使用的是mac，那么你就没有必要把一份文件到处复制保存了，你可以在需要的时候调出spotlight键入关键字就可以迅速找到本机中的相应文档了。 这就是搜索的美妙之处，它花费的时间大概还不及你把椅子转向抽屉的时间长。即使这份文件没有电子版也没关系，你可以扫描后存放在自己的电脑或者互联网上，等需要的时候再去搜索。 就在刚刚我要查看我的公积金账户，但是距离上一次使用已经过去快半年了，账号早已经忘记了，而且我也没有专门记录，于是我通过手机的邮箱客户端在搜索框中键入公积金三个字，在主题那个搜索结果列表中找到了当初公司发给我的公积金账户信息（太方便了！）。 借助搜索功能，你再也不必像过去那样，费劲心思想要把自己的信息资料存放的“井井有条”了。这就好比你再也不用一件一件地把所有衣服都挂好一样。相反，你只要把衣服扔到那个越来越高的大堆上就行。等你想穿那件印有ZERO TO ONE的T恤时，直接提出要求，那件衣服就像变魔术般的出现在了你的面前。这是多么轻松自由的感觉啊！（这也会减少磁盘空间的浪费你只需要128G的Mac和16G的iphone就行了甚至移动存储设备都可以被抛弃另外也可以把森林砍伐的风险降到最小）","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"http://logan62334.github.io/categories/生活随笔/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"http://logan62334.github.io/tags/生活随笔/"}]},{"title":"说说 Growth Hacker","slug":"说说 Growth Hacker","date":"2016-09-29T12:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/09/29/说说 Growth Hacker/","link":"","permalink":"http://logan62334.github.io/2016/09/29/说说 Growth Hacker/","excerpt":"","text":"大家应该注意到我的公众号改名了哈，今天就来随便聊聊我对”增长黑客”的认识。 最开始接触“增长黑客”（Growth Hacker）这个概念是源自一则关于Hotmail的营销事件。 1996年刚刚成立不久的Hotmail由于手头资金有限，他们仅靠在每一封用Hotmail发出的邮件末尾加上“我爱你，快来Hotmail申请你的免费邮箱。”这样一句简单的话，就给他们带来了每天3000个新用户的增长。 那么话说回来，到底什么才是“增长黑客”呢？ 在互联网公司中，增长黑客是游走在产品、运营、研发、设计、用研等环节之间的多面手。他们的唯一目标就是通过严谨的数据分析以最低的成本获得高用户增长。 那有人可能要问了，怎么才能成为一名增长黑客呢？其实不管现在你是拥有技术背景的产品经理，还是对产品运营感兴趣的研发工程师都有相对的优势，不过归根结底还是要专业技能过硬、经得起实战检验，才是最基本的准入门槛。 增长黑客要建立”T“型的知识结构——在横向上对跨界知识信手拈来、有机整合，在纵向上有某一领域的专攻，甚至达到旁人难以企及的深度。 就我的个人成长经验来说，由于从小就对黑客和互联网感兴趣，自从高一拥有了自己的第一台个人电脑之后便开始折腾各种操作系统和软件，随后通过frontpage搭建了自己的第一个静态博客，大学期间小打小闹的也创过业，在2012年的暑假第一次接触到Android开发，然后闭关苦学3个月给学校开发出了一款移动图书馆APP，并且成功在360手机助手和腾讯应用宝以及图书馆主页上线。由于本科学的是网络工程，因此在网络编程、黑客攻防、路由交换等方面也得到一些专业技能的加强。此外因为兴趣比较广泛，学过设计用的PS、运营用的公众号、数据分析用的GA、产品用的Axure等等。业余时间也喜欢写写博客，从CSDN免费博客到WordPress搭的动态博客再到现在的Hexo静态博客，慢慢也学到了一些排版和布局的文案技巧，毕业后的第一份工作加入了一家初创团队因此也有幸结实了一些优秀的产品经理、创业达人和投资人。 总的来说，一路野蛮生长，跌跌撞撞，体内吸收了不少“混乱”的能量。然而那些在当初看来任性妄为、无足轻重的经历，终将在某一日连点成线，开花结果。正如乔布斯在斯坦福毕业典礼上的演讲：“你不可能从现在预测到未来，只有回头看时，才会发现事物之间的联系。所以你必须相信，那些生命中的点点滴滴，将会在你未来的生命里，以某种方式串联起来。你必须始终相信一些东西——你的勇气、宿命、生活、因缘、随便什么，它们将给你追寻内心真正所想的自信，带你走离平凡，变得与众不同。”","categories":[{"name":"增长黑客","slug":"增长黑客","permalink":"http://logan62334.github.io/categories/增长黑客/"}],"tags":[{"name":"增长黑客","slug":"增长黑客","permalink":"http://logan62334.github.io/tags/增长黑客/"}]},{"title":"你有没有这些衣物？","slug":"你有没有这些衣物？","date":"2016-08-28T17:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/08/28/你有没有这些衣物？/","link":"","permalink":"http://logan62334.github.io/2016/08/28/你有没有这些衣物？/","excerpt":"","text":"最近感觉公号总写些技术类的文章不免有些枯燥，今天就开篇讲讲生活上一些值得思考的小事吧。 你的衣橱里有没有这些衣物？ 拿我自己来说，其实一直到高中毕业前我的大部分衣服、鞋子都是我母亲一手操办购买的，每次她买完回来让我试穿一下，如果尺码没什么问题我基本都会说OK的（可能当时我也确实没什么审美）。** 久而久之，每逢过年准备购置新衣服的时候就会发现还有一大堆的旧衣服静静的躺在衣橱内甚至有些压根都没有穿出去过。这个时候我大都会跟母亲说要不咱们扔掉一些吧反正留着也没用，可你们应该是知道的父母那辈人总是以节俭自居，So… 反观我大学期间，很多时候不管是因为网购便宜还是和周围人攀比，还是会有各种各样的无用消费（这里不单单是衣物还有各种电子消费品等）。 要重视价值而非价钱 买便宜货不是明智之举。大学头一两年因为花的是家里的钱所以比较省，有时候会在像双十一这样的大型网购节的时候一口气买好些便宜可质感差的衣服。数量再多，经常穿的也就那几件，其他依然是闲置。 花大价钱也不是长久之计。一个人的形象好不好，不是靠几个奢侈品就能改变的。这让我想起了之前看到的一篇文章《为什么法国女人不买名牌包？》，文中讲了其实她们并不是买不起那一个包，她们是买不起和那个包等值的全套东西。不想打肿脸，硬塞进那个不属于她们的阶级。有什么比背着香奈儿的包，去挤地铁更让人心酸的事情呢？时尚是用钱砸出来的，可也得看砸在了什么地方。如果说服饰能推动你的人生顺丰顺水，那才值得投资。 定期整理下衣物，该扔就扔 这些年，我基本定期就会收拾一次家，每次都能扔掉一大箱子的东西，其中衣物居多其次是些电子产品之类的。说实话每次扔完心情就会特别好，感觉世界又清爽了好多，我扔东西的原则是：近一年没穿过的衣服鞋子、未来半年不会再用到的生活用品、功能重复的电子产品还有好多失去收藏意义的摆件。 说到扔东西，我们真的还会去穿那些一年都没有碰过的衣服嘛？ 不。 很多人压根就再也不会去穿了，每次从一个储物箱挪到另一个，但有人心里可能就想了在衣橱里多放一两件衣服又不是什么大事万一哪天用的到呢，至少它还在那儿，不是么？ 一两件这样的衣服的确不是问题，但是如果抱定这样的想法，年复一年，怕是衣橱里已经堆满了太多无用的衣服，反而是那些真正有用的没有搁置的地方了。 关于是否要留下这些衣服，这种想法明确地把人分为不同的两群。 觉得需要留下的人，心心念念在自己得到的东西上，生怕有任何损失，我们可以把这种心态下的人生称之为“存量人生”。 而觉得不需要留下的人，他们努力探寻这个世界的真实，用理性控制自己的情绪，小心翼翼地和万兽群奔保持距离。他们的想法是审慎地分析评估真正对自己有用的东西，目的是带上最少的负担和给养，好继续向前飞奔，可以把这种心态下的人生称之为“增量人生”。 不同的人生态度会带来不同的结果 和所谓关键处的几次选择相比，在某种人生态度下日复一日的践行，对人生的决定性作用可能更大。追求存量者到最后往往两手空空，追求增量者很可能不求自得。从更长的时间尺度上来看，在出发点上的毫厘之差，也许会在其后拉开惊人的距离。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"http://logan62334.github.io/categories/生活随笔/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"http://logan62334.github.io/tags/生活随笔/"}]},{"title":"静态网站的动态化","slug":"静态网站的动态化","date":"2016-08-26T12:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/08/26/静态网站的动态化/","link":"","permalink":"http://logan62334.github.io/2016/08/26/静态网站的动态化/","excerpt":"","text":"说到静态网站的动态化，其实就跟想减肥又不愿多运动一个道理，那到底鱼和熊掌能不能兼得呢？静态网站确实有诸多优点但它的部署发布流程太繁琐了，之前我为了偷懒写了一个脚本每次写完文章一键发布！ 后来在一次team分享会上cc同学提出了一个小创意说现在静态网站+markdown的组合非常流行，我们可不可以做一个移动版的app随时把写好的文章以静态网站的形式发布出去？而且兴致勃勃的说目前没有人这么做如果做出来肯定会火一把😄 。 最近在看持续集成相关的文章，然后发现完全可以通过CI+静态网站生成器+github手机客户端完成之前的idea，于是google了一下发现很多文章都有讲如何通过Travis、flow.ic等持续集成工具来发布由hexo、Jekyll等等静态网站生成器构建的博客，这仿佛也印证了那句话“当你想到一个idea的时候，可能有1000个人已经想到了，100个人在计划了，10个人准备全力去做了，一个人已经干出来了” 不过关键还是看执行力。 既然网上很多文章都有讲为什么还要来写这篇文章呢？还不是因为各种坑嘛，在实际搭建部署的过程中遇到各种莫名的环境配置问题，思路大家都懂😂 关于持续集成和静态网站生成器之类的概念在这里就不重复讲了，有问题自行google。 我的博客框架 我的博客系统是用Hexo+Travis CI+Github搭建的。因为要使用Gitpage服务，所以生成的网页文件必须是在master分支 master分支用来存放生成的Html文件 blog_source分支用来存放博客源文件 在Github上生成Access Token 在github的设置页面，点击左侧的Personal access tokens，然后点击右上角的Generate new token按钮，他会让你输入密码，最后进入下图的页面： 这里需要注意因为你要把这个token给CI服务器所以为了安全起见尽量只给必要的权限即可。 Travis CI的环境配置 这里我们把一些敏感的信息都配置在CI服务器上，例如：github的用户名、邮箱、Gitpage的地址、还有刚刚生成的Token。 .travis.yml的配置 这里我们还需要在存放博客源码的仓库里创建一个.travis.yml配置文件，如下图： 内容如下： 12345678910111213141516171819202122232425262728language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install - npm install -S hexo-generator-json-content#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name &quot;$&#123;USER_NAME&#125;&quot; - git config user.email &quot;$&#123;EMAIL&#125;&quot; - git add . - git commit -m &quot;Update docs&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master# E: Build LifeCyclebranches: only: - blog_source 其中变量的含义： GH_TOKEN——访问github的token GH_REF——博客托管在Gitpage上的地址 USER_NAME——github的用户名 EMAIL——github的邮箱 愉快的发布文章 1、通过Android studio来管理发布博客在AS中有很多不错的插件来支持markdown，这样我们就可以像平时写代码一样来写文章了，完成之后push到服务器，CI那边就会自动编译发布。 2、通过github网站直接发布文章这种方式就更不依赖环境了，只要有一台可以联网的设备你就可以开心的写文章了。 3、通过github手机客户端github推出了Android版的客户端，这样写文章是不是更容易了呢","categories":[{"name":"CI","slug":"CI","permalink":"http://logan62334.github.io/categories/CI/"}],"tags":[{"name":"CI","slug":"CI","permalink":"http://logan62334.github.io/tags/CI/"}]},{"title":"[译文] 我不使用Android Data Binding的四个理由","slug":"译文-我不使用Android-Data-Binding的四个理由","date":"2016-08-14T19:06:56.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/08/14/译文-我不使用Android-Data-Binding的四个理由/","link":"","permalink":"http://logan62334.github.io/2016/08/14/译文-我不使用Android-Data-Binding的四个理由/","excerpt":"","text":"为什么我还在用ButterKnife。 免责声明：本文是基于个人经验和实践可以随意反驳，是否采纳自行决定。 1、专家不建议这么做ButterKnife的作者Jake在下面这个github issue中直指要点。 data binding在最简单的场景下是比较有用的。但它并没有什么创新，所以在复杂度增加的情况下还是会像其他平台上的解决方案一样用起来非常痛苦（例如：XAML）。当这个库扩展到高级的情况下，将会迫使你把绑定的逻辑写到代码中，那里才是它真正该在的地方。 事实上，我同意其中的两点： 1、它的扩展性并不好。2、业务逻辑应该在代码中。 2、它让你写出意大利面式的代码一旦我们开始实现复杂的布局，将会使我们的Data Binding解决方案越来越复杂。 首先我们将会面临下面的问题： 1、Layout 要求你给他们分别传递数据。 2、你也可能想为你的布局创建不同的数据源。 3、同样的问题也会在ViewStubs中发生。 4、当你使用Picasso加载图片的时候，你需要为他实现一个自定义的data binding adapter，那样的话你就不能作为依赖mock和注入了。 我们可能会试着做些更复杂的事情： 1、在layout中增加presentation的逻辑。12345&lt;TextView android:text=&quot;@&#123;user.lastName&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt; 2、在listeners中增加Lambda表达式。1android:onLongClick=&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot; 3、在layouts中使用导入的class类。123&lt;data&gt; &lt;import type=&quot;android.view.View&quot;/&gt;&lt;/data&gt; 我们的逻辑一部分在代码中一部分在布局文件中，这将很快变成一个噩梦，并且闻起来像是意大利面式的代码。 3、单元测试也不能用了我非常喜欢Robolectric和Mockito，他们节约了我很多时间在创建和运行测试实例的时候，没有了他们我将无法工作。 Data Binding的一个特性对于我来说是一个bug：如果layout发生了异步更新，那就意味着在我设置了绑定之后单元测试中我无法确定view上的数据是否正确。 我记得google用Espresso实现的测试框架，但如果有可能的话我还是希望用单元测试的方式来测UI。我喜欢将Activities、Fragments和Views分开来测试而不是在一个大的Instrumentation Test中导入他们。 4、它比ButterKnife提供的功能少很多ButterKnife提供了很多不错的特性，可能有些我们都不记得了： 1、资源绑定 2、View 列表 3、多个监听器的绑定 当我们用自定义控件做一些高级的实现的时候，资源绑定是非常有用的，我们可以通过它获取到Dimensions和Drawables。 当我们有一系列的视图触发同样的操作的时候，多视图绑定和多监听器绑定会让我们少写很多代码，例如：一系列的EditText和Buttons。 而如果你使用Data Binding库将得不到这些功能。 为什么你会使用Data Binding 1、我可以开发的更快长远来看，快速并不一定总是好的。当我们开发app的时候，我们是在跑一场马拉松而不是一次百米冲刺……不是吗？ 2、它已经存在于系统sdk中不需要引入第三方库总归是好事情。如果你被调入到一个已经出现了方法数快超过限制的项目中时，你的leader将不希望你再引入过多的第三方库。 3、我在遵循MVVM的模式如果你正确的利用观察者模式实现了MVVM，Data Binding库将会帮助你在views中实现观察者模式。 谢谢你看了这么长时间！","categories":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/categories/Android译文/"}],"tags":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/tags/Android译文/"}]},{"title":"[译文] Android开发最佳实践","slug":"译文-Android开发最佳实践","date":"2016-08-06T10:53:33.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/08/06/译文-Android开发最佳实践/","link":"","permalink":"http://logan62334.github.io/2016/08/06/译文-Android开发最佳实践/","excerpt":"","text":"你的软件开发效率不仅仅取决于你有多么深的知识和经验，还依赖于你的开发工具、环境配置和团队协作能力。 我最近在 Droidcon Berlin做了一个关于在我们Zalando Tech team的一个Android开发者最佳实践的分享。接下来你可以找到我演讲中的一些要点，将使你的开发生活更加愉快并且让你的应用更加稳定。 1、你的AndroidManifest文件真实的样子是什么我们大多数人早已知道我们在文本编辑器中看到的AndroidManifest.xml 文件跟实际编译好生成的的内容并不一样。这主要是因为你在工程中包含的第三方库中存在额外的&lt;uses-permission/&gt;标签，将和你自己的manifest文件混合。（The Commons Blog查看更详细的信息） 在构建APK前检查你的manifest，我们可以用Android Studio 2.2中提供的新特性：Merged Manifest Viewer。这个工具将会给你展示你的AndroidManifest是如何基于build types, flavors, and variants这些配置和你的依赖包merge的。你可以导航到AndroidManifest.xml文件点击底部的Merged Manifest标签使用这个工具。 2、Support annotations是你的朋友另外一个特别有用的工具是support annotations library。你可以通过在你的build.gradle文件中添加“com.android.support:support-annotations:23.4.0” 来包含入你的工程。使用这些metadata annotations去修饰你的代码帮助你发现bug定义编码规则。最常规的使用场景是标记nullable和non-nullable，链接资源，并且指定从哪个线程被回调。 既然这些annotations是metadata annotations，所以即使你违反了它定义的语法规则你的工程也会编译。然而它会被Android Studio 和 Lint标记为高亮，并且在你的持续集成工具输出中对你的团队成员是可见的。 3、快速、无痛的code review假设你想要去做一个code review，检查开发feature是如何工作的是有意义的，所以你需要去编译你的工程。这种情况有下面这样的一种通用工作流： 1.在你当前分支Stash changes2.Checkout branch来做review3.在你的IDE中重新加载gradle配置4.在IDE中读代码5.编译启动并且测试app6.重复 (1) — (5)的动作 “这里有什么问题吗？”你会问。是的，除了下面这种情况之外没什么问题，当你的工程有1000+的类和配置文件不同的时候你将会用你强劲的MacBook花超过三分钟用在编译你的代码上。 我们的解决方案是使用一个专用的IDE实例和存储库文件夹来做code review。在这种情况下你的工作在一段时间内不会停止，你可以在任何时候回到你的主IDE和分支。这里有个小的免责声明：我们建议你使用一台至少有16GB RAM的机器，它为你节省的时间绝对非常值。 4、快速的应用修改即使你的工程很小，你会经常花时间在编译部署最新的变化到测试机和模拟器上。如果你有上百个类和xml文件，每次编译和部署会花去你很多时间，即使你用配置很高的电脑。此外，你需要手动定位到应用变化的地方，这也需要一些时间。 在2015年底，Android社区收到两个可以让代码变化应用得更快的工具。第一个是JRebel，它是来自Java后端世界并且已经成为很长一段时间的行业标准。另外一个工具便是google在Android Studio 2.0中发布的Instant Run，这些工具都有共同的目的，但是JRebel有更多的特性，并且需要按年支付许可证。 这两个工具单看看不出有什么不同，于是我们通过文档和一些博客分析了他们的不同： 来源：https://developer.android.com/studio/run/index.html#instant-runReto Meier: “Instant Run: How Does it Work?!”Oleg Selajev: “Looking at JRebel for Android and Instant Run …” 几乎每周这两个工具都在积极的开发和改进。根据我们的经验，虽然很多用例还没有涉及，但你已经可以受益于这些工具了。 5、衡量执行时间另一个非常有用的特性是在应用程序调试和性能分析日志记录方法输入/输出和执行时间。对于这些需求，我们使用一个简单的和优雅的方法注释工具——Hugo by Jake Wharton。如果你仅仅只是想看日志输出并不需要像Systrace这样深度和复杂的工具。 你需要做的只是去标注目标方法，如图所示：12@DebugLogpublic String getName(String first, String last) &#123;/* ... */&#125; 在日志中找到相应的方法调用的打印信息：12V/Example: --&gt; getName(first=&quot;Jake&quot;, last=&quot;Wharton&quot;)V/Example: &lt;-- getName [16ms] = &quot;Jake Wharton&quot; 6、如何从你的设备上读取日志输出信息为了日常的需要，我们大多数人使用Android Studio内置的Monitor来读取日志。在简单的场景下它使用很方便，但我们注意到几个权衡使用这种方法: 1.日志是难以阅读,你应该使用外部工具或格式化配置。 2.Android Studio的日志工具是和你部署的应用程序的进程ID关联的。如果你重新部署应用程序或杀死进程,你以前的日志都会丢失,因为Android Studio是跟进程ID绑定的。 为了解决这个问题我们可以使用Jake Wharton — pidcat。它的主要好处如下： 1.好颜色模式和格式。 2.由包名称连接到调试应用程序,而不是进程ID。所有的日志都将被保持在重新部署应用程序后。 7、网络输出日志记录和分析最常见的阅读你应用网路交互日志输出的方式是通过HTTP客户端。然而,这种方法有几个权衡: 1.如果你要在开发过程中保持所有的网络请求日志，你将注意到,应用程序的性能有所下降,需要一些时间来打印日志。 2.如果你的应用有一些额外的库需要用到网络，（例如：Google Analytics）你需要为这些额外的库做一些配置 来让所有的数据被记录。 这里有另外一种方法：使用HTTP监控软件 Charles Proxy，这种类型的工具会提供如下的功能，把你的应用包装为黑盒： 1.HTTP/HTTPS通道的监控和记录 2.重新修改返回值和服务器响应的边界情况 3.在网络回调的地方打断点 4.将SSL证书安装到设备读取加密流量 更新，评论中 Nahuel Barrios提到的另外一个可以替代的网络监控工具是 Facebook Stetho我们仍然不能通过Stetho读取Google Analytics中的SSL加密的通信信息，如果你知道任何关于这个的信息请联系我。 8、保证在不同版本的操作系统上测试我一直在做并且推动我同事做的事情是在Lollipop和更高的(API 21+)的版本中测试每一个功能。这样我可以在测试期间捕获这些bug。 你会发现通常的兼容问题都是些触摸反馈和系统颜色的不一致，我们经常看到app由于兼容问题在老的API中崩溃。 9、自动化屏幕交互测试我们经常需要检查一些场景在不同设备上做重复的UI点击和输入。如果你有三到四台测试设备那将是非常烦人的，你需要一个回归测试计划去测试通过30各场景。 自动化的第一步，我们通过输入adb命令或者脚本去实现从而避免每次都要手动和设备交互。你可以通过系统按键、键盘输入和屏幕触控来实现adb命令的输入。 但是如果你有三台设备要同时测试一个场景，你会怎么做？我们可以使用adb-ninja来让不同设备同时测试。 10、检查你的build.gradle配置有时甚至一些有经验的开发者也会使用一些过时的配置实践。让我们检查一下你的build.gradle文件，看看你有没有中招： 1.舍弃mavenCentral，去用jcenter作为依赖仓库。jcenter拥有更快的响应时间并且已经集成了mavenCental的内容。 2.检查Android Plugin for Gradle的版本，保持最新的版本可以提高编译性能并且会得到像Instant Run这样好用的功能。 3.不要指定依赖库的版本范围，要使用像“23.4.0”这样的版本常量，减少每次编译依赖库时的网络请求。 4.设置编译版本minSdkVersion 21或者更高，将会提高构建速度。","categories":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/categories/Android译文/"}],"tags":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/tags/Android译文/"}]},{"title":"[译文] 如何正确在闪屏页加载耗时的库","slug":"译文-如何正确在闪屏页加载耗时的库","date":"2016-07-27T21:30:47.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/07/27/译文-如何正确在闪屏页加载耗时的库/","link":"","permalink":"http://logan62334.github.io/2016/07/27/译文-如何正确在闪屏页加载耗时的库/","excerpt":"","text":"在这篇文章中我想展示的是当开发人员有一个初始化很慢的库时可能不希望在主线程中来初始化这个库，因为它将阻塞UI线程使应用无响应。相反，开发人员希望在后台加载它，然后将结果通知到主线程中。 闪屏页首先，如果你已经有一些初始化的东西在自己定义的application中，你可能需要一个适当的闪屏页。这意味着当点击应用程序图标的同时应该出现闪屏页。它可以很容易通过设置SplashActivity的主题背景实现。 123&lt;style name=&quot;SplashTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/background_splash&lt;/item&gt;&lt;/style&gt; 在你的AndroidManifest.xml中 12345678&lt;activity android:name=&quot;.splash.SplashActivity&quot; android:theme=&quot;@style/SplashTheme&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 通常闪屏页是一个logo，所以这个@drawable/background_splash可以是一个layer-list，例如： 123456789&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;item&gt; &lt;bitmap android:gravity=&quot;center&quot; android:src=&quot;@drawable/ic_hockey_stick&quot;/&gt; &lt;/item&gt;&lt;/layer-list&gt; 关于这个的实现就到这里。 顺便说一句，如果你使用作为你bitmap的资源，注意这个bug。不幸的是，没有相应的解决方案所以在API版本小于23的情况下闪屏页中的图片要用png格式。 初始化库现在我们有了闪屏页，接下来干什么呢？现在我们应该考虑一下如何加载这些耗时的库了，Dagger 2和RxJava来救驾！ 如果这个漫长的初始化库只是需要在闪屏页加载一些数据的话我们可以把它定义在SplashModule中，这样的话当我们不再使用的时候可以清除掉它的引用。 1234567@Modulepublic class SplashModule &#123; @Provides @NonNull @SplashScope public SplashLibrary splashLibrary() &#123; return new SplashLibrary(); // Takes &gt;5 seconds. &#125;&#125; 目前我们还不能在任何地方注入这个库，因为它会阻塞UI线程。我们将会创建一个Observable来接受SplashLibrary实例，但仍然不会被初始化因为我们通过Lazy&lt;&gt; 实例化它。 12345678910111213@Modulepublic class SplashModule &#123; // ... @Provides @NonNull @SplashScope public Observable&lt;SplashLibrary&gt; observable(final Lazy&lt;SplashLibrary&gt; library) &#123; return Observable.defer(new Func0&lt;Observable&lt;SplashLibrary&gt;&gt;() &#123; @Override public Observable&lt;SplashLibrary&gt; call() &#123; return Observable.just(library.get()); &#125; &#125;); &#125;&#125; 注入这个库最后我们可以在SplashActivity中注入Observable 123456789101112131415161718192021222324252627/** Observable which will emit an item when fully initialized. */@Inject Observable&lt;SplashLibrary&gt; splashLibraryObservable;/** Subscription to unsubscribe in onStop(). */private Subscription subscription;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // ... subscription = splashLibraryObservable // Init library on another thread. .subscribeOn(Schedulers.computation()) // Observe result on the main thread. .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;SplashLibrary&gt;() &#123; @Override public void call(SplashLibrary splashLibrary) &#123; // Use the initialized library. Intent intent = new Intent(activity, MainActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 这里仍然有一些需要注意的坑：1、这个库可能抛出异常=&gt;我们需要实现onError()方法。2、当我们在初始化完成前离开或者旋转页面时可能会导致内存泄露因为我们在回调方法中持有activity的引用。 处理当初始化一个重量级库的时候引发的错误为了解决这个问题，我们可以通过一个Observer订阅subscribe()。非常简单： 123456789101112131415161718192021.subscribe(new Observer&lt;SplashLibrary&gt;() &#123; final String TAG = &quot;Observer&lt;SplashLibrary&gt;&quot;; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;Library init error!&quot;, e); // Possible UI interaction. // ... finish(); &#125; @Override public void onNext(SplashLibrary splashLibrary) &#123; // ... // Use the initialized library. Intent intent = new Intent(activity, MainActivity.class); startActivity(intent); finish(); &#125;&#125;); 处理当用户离开activity页面时引发的内存泄露问题在这个例子中我们仅仅从Subscription取消订阅是不够的，因为当对象正在初始化的过程中Subscription不能释放资源从而是我们在内存中持有已经销毁的activity的资源导致内存泄露。如果在Application中开启了StrictMode.enableDefaults();我们很容易在LogCat中看到，当旋转activity页面日志如下： 123E/StrictMode: class .SplashActivity; instances=2; limit=1android.os.StrictMode$InstanceCountViolation: class .SplashActivity; instances=2; limit=1at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1) 这就是为什么我们需要去释放在Observer创建中持有的对activity的引用，我们可以通过创建一个实现了Observer的静态类来实现，并且在onDestroy()中清除引用，通过这种方法我们可以确保没有任何泄露。 123456789101112131415private static final class OnInitObserver implements Observer&lt;SplashLibrary&gt; &#123; @Nullable private SplashActivity splashActivity; OnInitObserver(@NonNull SplashActivity splashActivity) &#123; this.splashActivity = splashActivity; &#125; @Override public void onCompleted() &#123; /* ... */ &#125; @Override public void onError(Throwable e) &#123; /* ... */ &#125; @Override public void onNext(SplashLibrary splashLibrary) &#123; /* ... */ &#125; public void releaseListener() &#123; splashActivity = null; &#125;&#125; 12345@Override protected void onDestroy() &#123; super.onDestroy(); onInitObserver.releaseListener();&#125; 记住这些点，可以在闪屏页中很容易初始化一个库、发起一个网络请求或者做一些复杂的处理。 感谢阅读！源码在这里","categories":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/categories/Android译文/"}],"tags":[{"name":"Android译文","slug":"Android译文","permalink":"http://logan62334.github.io/tags/Android译文/"}]},{"title":"[Android] 优雅的处理登录页面跳转逻辑","slug":"Android-优雅的处理登录页面跳转逻辑","date":"2016-07-10T13:12:35.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/07/10/Android-优雅的处理登录页面跳转逻辑/","link":"","permalink":"http://logan62334.github.io/2016/07/10/Android-优雅的处理登录页面跳转逻辑/","excerpt":"","text":"一般有用户系统的应用都会有以下两种需求：1、在执行某个动作时需要判断当前用户是否登录，如果没有登录则跳转至登录页面，登录成功后返回原页面但不执行任何操作，如果已经登录则直接执行相应的操作。2、在执行某个动作时需要判断当前用户是否登录，如果没有登录则跳转至登录页面，登录成功后返回原页面继续执行相应的操作，如果已经登录则直接执行相应的操作。但往往一个应用中会有很多地方需要有这样的判断逻辑，所以直觉告诉我们应该把这一重复的处理逻辑封装一下： 1、定义工具类LoginUtil.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LoginUtil extends Activity &#123; private int REQUEST_CODE_LOGIN = 1; static LoginCallback mCallback; public interface LoginCallback &#123; void onLogin(); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, LoginActivity.class); startActivityForResult(intent, REQUEST_CODE_LOGIN); &#125; public static void checkLogin(Context context, LoginCallback callback) &#123; //此处检查当前的登录状态 boolean login = AccountMgr.get().isLogin(); if (login) &#123; callback.onLogin(); &#125; else &#123; mCallback = callback; Intent intent = new Intent(context, LoginUtil.class); context.startActivity(intent); &#125; &#125; public static void checkLogin(Context context, LoginCallback logged, LoginCallback callback) &#123; //此处检查当前的登录状态 boolean login = AccountMgr.get().isLogin(); if (login) &#123; logged.onLogin(); &#125; else &#123; mCallback = callback; Intent intent = new Intent(context, LoginUtil.class); context.startActivity(intent); &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; finish(); if (requestCode == REQUEST_CODE_LOGIN &amp;&amp; resultCode == RESULT_OK &amp;&amp; mCallback != null) &#123; mCallback.onLogin(); &#125; mCallback = null; &#125;&#125; 2、在AndroidManifest.xml里配置此activity的主题123&lt;activity android:name=&quot;com.xxx.base.utils.LoginUtil&quot; android:theme=&quot;@style/NoDisplay&quot; /&gt; 注意：在values中创建主题：1&lt;style name=&quot;NoDisplay&quot; parent=&quot;android:Theme.NoDisplay&quot;/&gt; 在values-v23中创建适配主题：1&lt;style name=&quot;NoDisplay&quot; parent=&quot;android:Theme.Translucent.NoTitleBar&quot;/&gt; 3、在登录页面成功登录后执行下面语句：12345@Subscribe(threadMode = ThreadMode.MAIN) public void onEventMainThread(AccountEvent.LoginEvent event) &#123; setResult(Activity.RESULT_OK); finish(); &#125; 4、在需要判断登录的地方直接调用下面两种重载方法即可：12345LoginUtil.checkLogin(getActivity(), new LoginUtil.LoginCallback() &#123; public void onLogin() &#123; //已经登录和未登录状态下进行的操作 &#125; &#125;); 12345LoginUtil.checkLogin(getActivity(), new LoginUtil.LoginCallback() &#123; @Override public void onLogin() &#123; //已经登录状态进行的操作 &#125; &#125;, null);","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/tags/Android笔记/"}]},{"title":"[两周阅读清单] Realm、单元测试、Rxjava、读书","slug":"两周阅读清单-Realm、单元测试、Rxjava、读书","date":"2016-06-19T17:15:44.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/06/19/两周阅读清单-Realm、单元测试、Rxjava、读书/","link":"","permalink":"http://logan62334.github.io/2016/06/19/两周阅读清单-Realm、单元测试、Rxjava、读书/","excerpt":"","text":"为什么这次是两周呢？是因为上周去南京浪了所以没更😂 文章Android单元测试系列文章这系列文章是蘑菇街的小创发表的，应该是目前为止我知道的讲Android单元测试最系统全面的了，大家关于一切单元测试的问题和疑惑都可以在这里找到一些参考。 是时候学习RxJava了这篇文章讲了RxJava的多种使用场景，有很多有趣的用法。 更优雅的 Android 发布自动版本号方案如果你的项目是用 Git 管理的，并且恰巧又是使用 Gradle 编译，那么这里有一种更加优雅的自动版本管理方法。 『直播』大时代之前一直不理解为什么直播能火，看了一些文章之后慢慢有了一些认识了。 书单《人类简史》这是最近一段时间读过的书中感觉最好的一本了，不要被它的标题迷惑了，其实它不是一本单纯讲历史的书籍，其中涵盖了很多社会人文科学自然等多领域的知识和他们之间内在的一些联系，时不时就应该充实一下自己的精神世界，哈哈。 开源库Realm这个库更新的挺快的，现在正式版已发亲测非常高效，而且最近在WWDC上也提到了。 FileDownloader这是流利说团队开源的一个下载引擎的库，提的issue回复很快，同时亲测很好使。","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[Android] ViewPager的notifyDataSetChanged刷新无效果的解决方案","slug":"Android-ViewPager的notifyDataSetChanged刷新无效果的解决方案","date":"2016-06-05T16:11:55.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/06/05/Android-ViewPager的notifyDataSetChanged刷新无效果的解决方案/","link":"","permalink":"http://logan62334.github.io/2016/06/05/Android-ViewPager的notifyDataSetChanged刷新无效果的解决方案/","excerpt":"","text":"最近在开发中遇到了一个问题：ViewPager设置的PagerAdapter调用notifyDataSetChanged()时界面无刷新以至于影响到功能的实现。不过有一个很傻的方法倒是可以解决就是给Viewpager重新设置一次适配器，下面我来分享一下如何优雅的解决这个问题吧。 大家进入ViewPager的源码可以看到下面的代码段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Set a PagerAdapter that will supply views for this pager as needed. * * @param adapter Adapter to use */ public void setAdapter(PagerAdapter adapter) &#123; ...... if (mAdapter != null) &#123; if (mObserver == null) &#123; mObserver = new PagerObserver(); &#125; mAdapter.setViewPagerObserver(mObserver); ...... &#125; ...... &#125; private class PagerObserver extends DataSetObserver &#123; @Override public void onChanged() &#123; dataSetChanged(); &#125; @Override public void onInvalidated() &#123; dataSetChanged(); &#125; &#125; void dataSetChanged() &#123; ...... for (int i = 0; i &lt; mItems.size(); i++) &#123; final ItemInfo ii = mItems.get(i); final int newPos = mAdapter.getItemPosition(ii.object); if (newPos == PagerAdapter.POSITION_UNCHANGED) &#123; continue; &#125; if (newPos == PagerAdapter.POSITION_NONE) &#123; mItems.remove(i); i--; if (!isUpdating) &#123; mAdapter.startUpdate(this); isUpdating = true; &#125; mAdapter.destroyItem(this, ii.position, ii.object); needPopulate = true; if (mCurItem == ii.position) &#123; // Keep the current item in the valid range newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate = true; &#125; continue; &#125; ...... &#125; &#125; 意思是如果item的位置如果没有发生变化，则返回POSITION_UNCHANGED；如果item的位置已经不存在了，则回了POSITION_NONE。 解决方案1234567891011121314151617private class SetDialogAdapter extends PagerAdapter &#123; private int mChildCount = 0; @Override public void notifyDataSetChanged() &#123; mChildCount = getCount(); super.notifyDataSetChanged(); &#125; @Override public int getItemPosition(Object object) &#123; if (mChildCount &gt; 0) &#123; mChildCount--; return POSITION_NONE; &#125; return super.getItemPosition(object); &#125;&#125; 我们覆盖getItemPosition()方法，当调用notifyDataSetChanged时，让getItemPosition方法强行返回POSITION_NONE，从而让ViewPager重绘所有item。","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/tags/Android笔记/"}]},{"title":"[Android] 6.0 系统权限适配实践","slug":"Android-6-0-系统权限适配实践","date":"2016-05-28T09:56:06.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/05/28/Android-6-0-系统权限适配实践/","link":"","permalink":"http://logan62334.github.io/2016/05/28/Android-6-0-系统权限适配实践/","excerpt":"","text":"Android 6.0也已经出来有一段时间了，其中的权限模式从一开始的全部列出授予，到后来的运行时动态申请，这对开发者来说是一个重要的变化，今天我来分享一下具体的实践过程。 首先检查一下你的项目中 targetSdkVersion，如果是 23及以上，则必须适配新的权限模式；如果是 23以下，则还是统一在安装时全部申请权限。然后你还需要了解哪些权限是危险权限、特殊权限以及正常权限。 接下来我们需要准备两个类：PermissionsChecker.java12345678910111213141516171819202122232425262728/** * 检查权限的工具类 * * @author mafei */public class PermissionsChecker &#123; private final Context mContext; public PermissionsChecker(Context context) &#123; mContext = context.getApplicationContext(); &#125; // 判断权限集合 public boolean lacksPermissions(String... permissions) &#123; for (String permission : permissions) &#123; if (lacksPermission(permission)) &#123; return true; &#125; &#125; return false; &#125; // 判断是否缺少权限 private boolean lacksPermission(String permission) &#123; return ContextCompat.checkSelfPermission(mContext, permission) == PackageManager.PERMISSION_DENIED; &#125;&#125; PermissionsType.java1234567891011121314151617181920212223242526272829303132333435/** * Created by mafei on 16/3/31. */public class PermissionsType &#123; /** * 读取手机权限 */ public static final int READ_PHONE_STATE_CODE = 1; /** * 获取相机权限 */ public static final int CAMERA_CODE = 2; /** * 获取存储权限 */ public static final int WRITE_EXTERNAL_STORAGE_CODE = 3; public static class PermissionsTypeExtend &#123; public static String toDescription(int type) &#123; switch (type) &#123; case PermissionsType.READ_PHONE_STATE_CODE: return &quot;需要在系统“权限”中打开“电话”开关，才能更好的为你服务&quot;; case PermissionsType.CAMERA_CODE: return &quot;需要在系统“权限”中打开“相机”开关，才能相机拍照&quot;; case PermissionsType.WRITE_EXTERNAL_STORAGE_CODE: return &quot;需要在系统“权限”中打开“存储”开关，才能离线缓存&quot;; default: return &quot;需要在系统“权限”中打开相关权限，才能更好的为你服务&quot;; &#125; &#125; &#125;&#125; 准备好这两个类之后，就可以在你需要进行权限申请和控制的地方写下面的代码了：12345678910111213141516171819202122232425262728293031323334353637383940private PermissionsChecker mPermissionsChecker; // 权限检测器 // 所需的全部权限 static final String[] PERMISSIONS = new String[] &#123; android.Manifest.permission.WRITE_EXTERNAL_STORAGE &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_movie_detail); mPermissionsChecker = new PermissionsChecker(this); &#125; if (VersionSDK.isMarshmallowOrHigher()) &#123; String[] permissions = PERMISSIONS; if (mPermissionsChecker.lacksPermissions(permissions)) &#123; requestPermissions(permissions, PermissionsType.WRITE_EXTERNAL_STORAGE_CODE); &#125; else &#123; //需要权限才能操作的代码 &#125; &#125; else &#123; //需要权限才能操作的代码 &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (requestCode == PermissionsType.WRITE_EXTERNAL_STORAGE_CODE) &#123; for (int i = 0; i &lt; permissions.length; i++) &#123; String permission = permissions[i]; int grantResult = grantResults[i]; if (permission.equals(android.Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; if (grantResult == PackageManager.PERMISSION_GRANTED) &#123; movieDetailIvCache.setSelected(true); &#125; else &#123; ToastUtils.showShortToast(&quot;需要存储权限&quot;); &#125; &#125; &#125; &#125; &#125;","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android 6.0","slug":"Android-6-0","permalink":"http://logan62334.github.io/tags/Android-6-0/"}]},{"title":"[一周阅读清单] 开发神器推荐","slug":"一周阅读清单-开发神器推荐","date":"2016-05-22T16:11:31.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/05/22/一周阅读清单-开发神器推荐/","link":"","permalink":"http://logan62334.github.io/2016/05/22/一周阅读清单-开发神器推荐/","excerpt":"","text":"『一周阅读清单』第五期与大家见面了，这周最大的新闻莫过于Google I/O 2016大会了，虽然自己没能到现场但各种现场的照片和新闻已经刷爆了朋友圈，其中比较吸引我的是Firebase、Android Instant Apps和Google Home，好了这次推荐几款开发神器。 StethoChrome的Developer Tools对于WEB开发者来讲几乎是一个神器，而Chrome Store里也有无奇不有的插件，如果Chrome能调安卓应用应该是一件美好的事，而Facebook开源的一个工具Stetho让Chrome调试android 应用不再是一个梦。安卓在调试时，有时候需要查看数据库，SharePreference等，而这个前提是必须root，另一方面，andoird的网络方面的抓包调试显得很困难，而这一切，Stetho都为我们轻轻松松地解决。除了使用android集成环境里的工具查看view树，使用Stetho也可以做到。 LeakCanary著名的开源组织 Square 开发了一套 Android 和 Java 内存泄露检测库。LeakCanary 是一个检测内存泄露的开源类库。你可以在 debug 包种轻松检测内存泄露。 Dex-Method-Countsdex-method-counts来统计包中的总体数量，使用方法很简单，只需执行下面语句即可： java -jar path\\dex-method-counts.jar path\\App.apk。 Android-Butterknife-ZeleznyAndroid Butterknife Zelezny这个插件，事实上这是个Android Studio的plugin，他可以让你在添加Butterkinfe注解时偷偷懒，直接点击几下鼠标既可以完成注解的增加，同时还是图形化的操作，可以说，大大的减轻了开发负担。尤其是当你的layout中有很多很多的view需要通过findviewbyid来获得引用时。 Android-Parcelable-Plugin手动实现Parcelable接口，往往需要写多些代码去实现，android-parcelable-plugin.可以让你几秒钟实现 Parcelable接口，让开发变得更开心。 AndroidWiFiADB你还在为在使用真机测试时，缺乏数据线而发愁吗？你还在为同事踩烂了你的一根数据线而耿耿于怀吗？（说实话我今天就被踩烂了一根） 你还在为每次用数据线连接真机测试时，都得抽拔抽拔而不耐烦吗？AndroidWiFiADB 通过WiFi 进行adb调试, 摆脱数据线。 GsonFormat这是一个根据JSONObject格式的字符串,自动生成实体类参数。 ACRAACRA是一个可以让安卓应用自动发出GoogleDoc格式崩溃报告的函数库。安卓开发者可以通过ACRA获取应用崩溃或者错误行为的数据。如果有一个崩溃发生，你的应用不会越过已有的系统崩溃提醒或者报告功能来添加用户提醒。如果使用Toast、状态提醒条或者直接对话框模式，这个“强制关闭”的对话框不会再显示，就算设备上原生系统的提醒功能开启也不能发送一个另外的报告。","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[一周阅读清单] 在线小工具推荐","slug":"一周阅读清单-在线小工具推荐","date":"2016-05-15T00:11:17.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/05/15/一周阅读清单-在线小工具推荐/","link":"","permalink":"http://logan62334.github.io/2016/05/15/一周阅读清单-在线小工具推荐/","excerpt":"","text":"『一周阅读清单』第四期与大家见面了，这周我大部分外业余时间都在看Python爬虫和JavaScript，所以今天给大家推荐一些之前收藏的实用在线小工具吧。 在线代码生成器，提高开发效率Android Layout Finder只需粘贴你的Android布局代码在第一个文本框，选择你需要的功能，就会自动生成代码。 Android KickstartR帮助您快速创建 Android应用程序并使用最流行的库进行配置。 它创建和配置你的项目给你。只专注于代码! Android Button Maker在线生成shape drawable XML代码 ，提供图形界面调试，更加直观。 Android Layout Parser工具输入你的字段的前缀，选择你的XML中的范围并点击生成，自动生成java代码。 Android资源生成分析工具Android Asset Studioicon制作（桌面icon，通知栏icon等），9patch图片制作，ActionBar样式等相关的工具。 Android Action Bar Style Generator自定义生成自己风格主题，图形化界面，直接下载相关的代码和资源。 Simple Nine-Patch Generator快速生成不同分辨率的资源。 Android Holo Colors Generator在线生成android的组件，如EditText、Radio等等，通过自定义自己的颜色风格。图形界面，简单可观。 Android Assets Viewer通过上传的自己的drawable resources，是否达到设计师的视觉效果。 Android SVG To VectorDrawable一个可以将SVG图片转换为Vector Drawable xml文件的在线工具。 计算转换工具Android Dp Px Calculatordp px 相互转换。 DP-PX-Converter自定义生成自己风格主题，图形化界面，直接下载相关的代码和资源。 Androidpixels不同分辨率下的转换数值。 PixelcalcAndroid pixel 计算器。 源码搜索引擎grepcode.com是一个Java源码搜索引擎，对于查看Android代码也不例外。并且支持多个API版本快速切换查看。如果你的IDE关联本地代码后，让机器累的喘不过气来，那么就试一试这个在线的工具吧。Grepcode支持多个API版本快速切换查看。 在线反编译当你还在花时间切换不同的反编译工具时，一个在线反编译网站应运而生，它就是Android APK Decompiler，只需上传要反编译的apk包，无需多时，源码可以下载下来了。Android APK Decompoler有两个在线反编译，简单容易，喜欢哪个用哪个。 Google Play（无需登录）由于一些你懂的原因，国内无法直接访问Google Play商店。而且下载Google Play商店还是需要登陆谷歌账户，以国内的网络，下载成功简直是太困难了。这里介绍一款不需要账户国内即可访问的Web工具。可以通过输入包名或者Google Play地址即可下载。快速下载Google Play应用下载Google Play的应用。 进制转换Android中所有的资源都有一个对应的资源ID，资源ID的类型为16进制的整数。有些时候特殊的场合处理资源ID，为了调试需要进行进制转换，比如16进制转常用的10进制。不用自己算，使用下面的工具就可以轻松搞定。进制转换在线快速转换，比如16进制转常用的10进制。 JSON格式化在CS应用中，客户端和服务器端通常使用json作为数据交换格式。当分析的时候，我们必然是将raw数据转换成可读性更高的。快来使用这个强大的工具吧。JSON格式化转成标准json格式。 API 市场收录网站各个领域的开发API，比如图片识别，语音合成，OCR等等一些生活常用的API开放接口，不需要后台也可以做一款使用的应用。API 市场图片识别，语音合成，OCR等等一些生活常用的API开放接口。 在线UML工具在线画流程图，如果你在家里用的MAC OX ,但是在公司用的是Linux ,那么导致UML图的转移不方便，这个在线的UML画图解决了一切问题。在线UML工具UML工具 、类图、流程图等等。 公开图标库国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能。公开图标库设计和前端开发的便捷工具。 批量图片压缩当图片很大的时候，又不想麻烦设计师，那么这个网站很适合你，批量压缩各种图片，直接把图片拖拉进去就行。批量图片压缩批量图压缩。 RGB转换通常UI设计师都会给开花童鞋色值，当疏忽的时候，我们可以使用截图软件得到10进制的三个值，然后将其转换成色值。这里有一个便捷的RGB工具。RGB转换RGB转换。","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[一周阅读清单] Gradle、CI、阅读、工具推荐","slug":"一周阅读清单-Gradle、CI、阅读、工具推荐","date":"2016-05-09T16:39:58.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/05/09/一周阅读清单-Gradle、CI、阅读、工具推荐/","link":"","permalink":"http://logan62334.github.io/2016/05/09/一周阅读清单-Gradle、CI、阅读、工具推荐/","excerpt":"","text":"『一周阅读清单』第三期与大家见面了，上周要说最火的事件应该就是百度和莆田系医院了，网上关于这一事件的文章论点铺天盖地，同时也涌现了很多用来公示和鉴别莆田系医院的工具和插件，文末我会推荐一个Chrome浏览器插件——打开莆田系医院网站，发出警告提醒、显示医院信息。 文章fir.im weekly - 「 持续集成 」实践教程合集我们常看到许多团队和开发者分享他们的持续集成实践经验，这里收集了 iOS，Android，PHP ，NodeJS 等项目搭建持续集成的实践，以及一些国内外公司的内部持续集成系统的经验，供大家集中研究，参考借鉴。 5分钟搞定android混淆混淆是上线前很重要的一个环节（是个脑力兼体力活）Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。这篇文章教你掌握正确的写混淆文件的姿势。 使用 MailOtto 做完美预加载Android预加载的实际案例。 Retrofit2 完全解析探索与okhttp之间的关系其底层对网络的访问默认也是基于okhttp，不过retrofit非常适合于restful url格式的请求，更多使用注解的方式提供功能。 Android N开发 你需要知道的一切Android N预览版运行是2016年3月9日，计划于2016年第三季度发布。一共有5个预览版，正常情况下，4到6个星期更新一个预览版，现在第二个预览版已经更新。在前三预览版google提供了一个测试和开发环境，你可以找出你的应用程序跟Android N系统的兼容性. 书单《深入理解Android内核设计思想》这本书从计算机操作系统的原理出发讲解了Android系统内核的设计思想，通过我们熟知的一些操作系统和网络知识来类比在Android中的应用。 《深入理解Android之Gradle》把gradle当做编程框架去学习，这样就不用每次去google如何如何配置脚本了，而且可以根据需要自己写脚本。 开源项目ExpandableLayout一个支持子view的展开与折叠的布局。 Tooltip轻量级的起泡提示。可以根据触发的位置灵活显示。 工具推荐免费翻墙镜像和工具科学上网必备。 莆田系医院网站提醒的Chrome插件本项目的意图是利用open-power-workgroup/Hospital收集汇总与国内一些医疗机构有关的信息，制作出来的一个莆田系医院网站提醒的Chrome插件，供广大寻医问药的患者及家属参考。","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[一周阅读清单] RxAndroid、Dagger2、动态配置、小工具推荐","slug":"一周阅读清单-RxAndroid、Dagger2、动态配置、小工具推荐","date":"2016-05-01T16:52:25.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/05/01/一周阅读清单-RxAndroid、Dagger2、动态配置、小工具推荐/","link":"","permalink":"http://logan62334.github.io/2016/05/01/一周阅读清单-RxAndroid、Dagger2、动态配置、小工具推荐/","excerpt":"","text":"『一周阅读清单』第二期与大家见面了，上周我去参加了中国架构师大会，后面我会将大会中的PPT下载地址贴出来分享给大家~ 文章从案例学RxAndroid开发 （上、下）上周推荐了一篇讲RxJava的好文，相信你一定很想了解RxJava如何在Android应用中使用它，这篇文章作者从实际案例出发讲解了这一实践过程。 用工厂流水线的方式来理解 RxJava 的概念RxJava 是款十分强大的工具。但不幸的是如果你之前没有通过“流”的形式写过代码你可能很难理解它并学会如何去用它。因为它十分不同于以往平常的安卓开发，所以我们需要一些比代码更形象的东西去理解它。这篇文章能帮助你更好地理解 RxJava 是如何工作的。 APP实时配置系统&amp;version=11020201&amp;pass_ticket=u%2FZBkB7zNcwIWqm7QWEqFXY9owAqv%2FNZTiIyX7eTHz21%2BNmsm0zUCP%2F9uJ0NpkS0)随着公司业务的发展，产品上经常需要对APP的逻辑进行更精准快速的变更，通过发布新版本的方式来调整逻辑已经满足不了这一需求了，所以各大公司开始实践动态配置方案，之前天猫无线团队也发表了一篇讲如何设计动态配置中心的文章。 Android：dagger2让你爱不释手这篇是滴滴出行的牛晓伟发表的一系列文章，总共三篇是目前我看到过最能把Dagger2讲的通俗易懂的文章了，看完确实爱不释手了！ Android单元测试(四)：Mock以及Mockito的使用这一系列文章很详细的讲了如何将单元测试运用到实际开发工作中，虽然很多人说在移动端做单元测试太浪费时间，蘑菇街的邹勇打了个比方我觉得挺形象的：相信很少人会说开车这件事情需要很多时间而是：1. 学习开车需要一定的时间；2. 如果路面不平的话，那么修路需要一定的时间，单元测试也是如此。 开源项目Depth-LIB-Android-一个给予view深度的library，同时也包含一些Canvas绘制技术的例子，比如波浪和噪点效果。 PLDroidPlayerPLDroidPlayer 是一个适用于 Android 平台的音视频播放器 SDK，可高度定制化和二次开发，为 Android 开发者提供了简单、快捷的接口，帮助开发者在 Android 平台上快速开发播放器应用。 agera谷歌的响应式编程框架，for Android。 小工具推荐Snapseed谷歌出品，图片后期处理利器。 Java 开发常用的在线工具对于一些简单的逻辑验证完全可以在这上面去编写运行。 最后附上中国架构师大会的PPT资料地址：http://note.youdao.com/share/?id=210afe4bc654668b08f709749b9f07d5&amp;type=note#/","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[一周阅读清单] RxJava、Gradle、动态化、小工具推荐","slug":"一周阅读清单-RxJava、Gradle、动态化、小工具推荐","date":"2016-04-24T01:59:24.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/04/24/一周阅读清单-RxJava、Gradle、动态化、小工具推荐/","link":"","permalink":"http://logan62334.github.io/2016/04/24/一周阅读清单-RxJava、Gradle、动态化、小工具推荐/","excerpt":"","text":"文章给Android开发者的RxJava详解其实网上有很多讲RxJava系列的文章但是对于Android开发者来说大部分都不能很清楚的讲明白什么是RxJava以及如何在Android中应用，这篇文章给以上问题做了一个很好的回答，值得一读。 用Retrofit 2简化HTTP请求这篇文章是Jake Wharton在Droidcon NYC 2015上的一次演讲，他很好的讲解了Retrofit的发展历史以及原理和应用。 团队中的Git实践这篇文章非常值得一读，讲解了在多人团队开发过程中需要注意的一些细节和概念。 关于Android 进程保活，你所需要知道的一切这篇文章比较全面的讲解了Android做进程保活的一些场景和对应的方案。 包建强：为什么我说Android插件化从入门到放弃？最近冒出了很多从入门到XX的书籍，哈哈 不过这篇文章是川哥的一篇采访录，文中包老师讲了些他自己对于Android插件化的一些看法，读后对插件化的概念和发展有了新的认识。 Growth: 全栈增长工程师指南这篇文章适合对全栈工程师感兴趣的同学阅读，用来科普比较不错。 GRADLE构建最佳实践这是阿里一位朋友写的，现在网上太多讲gradle的文章了，这篇是看下来感觉比较接地气而且很系统的讲了gradle的一些实用方法。 开源项目Facebook开源的Redex工具包FB最近放出了很多优秀的开源项目，总是能让人兴奋其中这个Redex是用来压缩和优化apk的，至于详细的实践过程可以参考我的上篇文章[Android] Facebook Redex 压缩优化Apk实践。 RealmRealm，为移动设备而生 替代 SQLite 和 Core Data。为你省下数周的时间和数千行的代码，帮你创造出更棒的用户体验。正如他官网所描述的又是一个杀手级插件。 Weex阿里对动态化的又一实践，这次阿里为了避免再出现开源项目无人维护的尴尬场景，于是这次像发布一个产品一样去发布了Weex，Weex支持iOS、安卓、YunOS及Web等多端部署，现已经开放内侧到6月份开源。 小工具推荐nearlock这是一款通过蓝牙自动检测距离来锁定解锁mac电脑的应用，亲测很好使不过只有付费版才支持后台运行。 AndroidWiFiADB这是AS上的一个插件可以帮助你实现无线调试。","categories":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/categories/一周阅读清单/"}],"tags":[{"name":"一周阅读清单","slug":"一周阅读清单","permalink":"http://logan62334.github.io/tags/一周阅读清单/"}]},{"title":"[Android] Facebook Redex 压缩优化Apk实践","slug":"Android-Facebook-Redex-压缩优化Apk实践","date":"2016-04-16T13:29:11.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/04/16/Android-Facebook-Redex-压缩优化Apk实践/","link":"","permalink":"http://logan62334.github.io/2016/04/16/Android-Facebook-Redex-压缩优化Apk实践/","excerpt":"","text":"最近Facebook 又放出了一个用于Android apk字节码优化的工具包——redex，经过redex的优化apk会变的体积更小，速度更快。至于原理大家可以到https://code.facebook.com/posts/1480969635539475/optimizing-android-bytecode-with-redex这个网站去看，今天我想分享一下具体的实践过程。 前两天刚看到FB放出的这个工具包就迫不及待的去尝试了下，结果一直报下面这个错误：1configure: error: Please install double-conversion library 但其实这些library都已经安装好了的，那天倒腾了好久也跟群里的朋友交流过，感觉应该是FB的一个小bug于是去github上提了issue，果然第二天得到了回应官方更新了使用说明。下面是我在Mac OS X上的实践过程： 1、首先需要你的Xcode安装了命令行工具： 1xcode-select --install 2、利用homebrew安装依赖包： 123brew install autoconf automake libtool python3 brew install boost double-conversion gflags glog libevent openssl brew link openssl --force 3、通过Git将redex的源码checkout到电脑上： 123git clone https://github.com/facebook/redex.git cd redex git submodule update --init 4、通过autoconf和make来构建redex： 12autoreconf -ivf &amp;&amp; ./configure &amp;&amp; make sudo make install 在执行步骤四的时候就出现了问题：12configure: error: Please install google-gflags library configure: error: ./configure failed for third-party/folly/folly 于是我又提了issue，下面是跟沟通的过程：按照他的方法执行下面的命令： 12xcode-select --install sudo xcode-select --switch /Library/Developer/CommandLineTools/ 再执行步骤四就OK了当然如果看到很多warn也不用担心，最终可以编译通过。接下来就可以通过redex执行最后的优化命令了： 1redex path/to/your.apk -o path/to/output.apk 不过这里又出现了个问题：又是环境问题😂 ,下面是配置过程：12mafeideAir:~ mafei$ vi ~/.bash_profile export PATH=/Users/mafei/Development/adt-bundle-mac-x86_64-20140702/sdk/build-tools/23.0.2:$PATH 因为这个是系统只读文件所以退出的时候要输入!wq才行这下执行下面的命令就完全没问题啦！ 123mafeideAir:~ mafei$ cd GitHub/mafeideAir:GitHub mafei$ cd redex/mafeideAir:redex mafei$ redex metis_release_v1.0.2.apk -o out.apk 刚刚又去看了下redex的官网发现FB已经把这几天遇到的一些典型问题都汇总了一下：","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android redex","slug":"Android-redex","permalink":"http://logan62334.github.io/tags/Android-redex/"}]},{"title":"[Android] 防止连续点击打开两个重复页面的小技巧","slug":"Android-防止连续点击打开两个重复页面的小技巧","date":"2016-04-12T23:00:28.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/04/12/Android-防止连续点击打开两个重复页面的小技巧/","link":"","permalink":"http://logan62334.github.io/2016/04/12/Android-防止连续点击打开两个重复页面的小技巧/","excerpt":"","text":"我们在开发APP的过程中经常会遇到在某些低端机或者在机器响应比较慢的情况下手抖连续点击某个页面（当然不排除有些人故意这么做）重复弹出好几个相同的页面，不过我发现微信这样的应用都没有做处理……但还是要分享一下我是怎么解决的。 1、通过判断两次点击的时间间隔来防止重复点击工具类：123456789101112131415161718192021222324 /** * Created by mafei on 15/12/8. */public class NoDoubleClickUtils &#123; private static long lastClickTime; private final static int SPACE_TIME = 500; public static void initLastClickTime() &#123; lastClickTime = 0; &#125; public synchronized static boolean isDoubleClick() &#123; long currentTime = System.currentTimeMillis(); boolean isClick2; if (currentTime - lastClickTime &gt; SPACE_TIME) &#123; isClick2 = false; &#125; else &#123; isClick2 = true; &#125; lastClickTime = currentTime; return isClick2; &#125;&#125; 使用方式：1234567891011/** * 点击事件 */ private View.OnClickListener logListener = new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (!NoDoubleClickUtils.isDoubleClick()) &#123; 事件响应方法 &#125; &#125; &#125;; 2、通过修改manifest中页面的launchMode属性改为单例模式12345&lt;!-- 市场网贷产品页 --&gt; &lt;activity android:name=&quot;.activity.market.CreditRecordActivity&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot; /&gt; 3、利用RxBinding实现防重复点击RxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。123RxView.clickEvents(button) .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(clickAction);","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/tags/Android笔记/"}]},{"title":"[Android] 移动开发技术周报 #198","slug":"Android-移动开发技术周报-198","date":"2016-04-03T18:18:35.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/04/03/Android-移动开发技术周报-198/","link":"","permalink":"http://logan62334.github.io/2016/04/03/Android-移动开发技术周报-198/","excerpt":"","text":"最近在浏览各大技术类资讯平台的时候发现Android Weekly是目前感觉在质量和时效性上都比较不错的平台，有兴趣的同学可以去http://androidweekly.net/ 订阅，但同时有了一个想法因为这个网站每次推送的都是纯英文版，说实话我一开始也是有点不太习惯因为阅读速度一下慢了好多，于是我打算试着去每周翻译一刊他们的推文希望可以为一些英文不太好但特别喜欢Android的同学带来些帮助，让大家可以快速了解目前的Android技术动态。 文章&amp;学习指南使用Design Support Library中的Bottom Sheets随着时间的推移Design support library在被慢慢的改善，在23.2版本中增加了对Bottom Sheets的支持，在本文中你将很轻松的学会如果在你的应用中实现Bottom Sheets。Android Thread Annotations的缺点当像@UiThread和@WorkerThread这样的Android thread annotations被发布的时候，Michael Comella 很兴奋，然后许多个月过后他发现这种注解并没有像他所希望的那样有效果但又不知道为什么，于是他决定研究一下。AutoValue Extensions谷歌的AutoValue库在即将发布的extensions中提供了简单的值类型，这个演讲介绍了这个扩展的功能，囊括了对Android有用的扩展并且在构建你自己的应用中提供一些建议。Vectors这是偶然在第三方平台上看到的一个关于Android VectorDrawable的支持包,另外Google发布了Android 23.2支持库,其中包含了备受期待的VectorDrawableCompat。五种很少有人知道的会阻塞主线程的情况一般来说，任何方法的调用导致主线程阻塞时间超过16*N毫秒都会引起掉帧。我们称这种方法为阻塞方法。在这篇文章中，我们将首先看一个阻塞方法的例子，然后再看五个阻塞主线程的方式。开源的Android LightCycleSoundCloud最近开源了LightCycle，LightCycle是一个Android库有助于把Activity和Fragment中的逻辑拆分成小的代码块。在Airbnb的Android版中采用RxJava这个演讲中分享了Airbnb采用这些新模式和技术的经验，以及遇到的困难和坑。第一个五年Mark Allison通过每周写很有深度的文章来跟我们分享他的Android知识，请一定要在Twitter或者G +上感谢他。RxJava的一些问题Thomas Nield写了一些在使用RxJava中你可能会遇到的一些问题 赞助Buddybuild：世界上第一个移动的持续集成平台Buddybuild是一个移动的持续集成和部署平台，只需要几分钟设置。我们的SDK使用户能够无比轻松地实时获取用户的反馈和崩溃报告。不用再维护不同的构建、部署、崩溃报告和反馈系统。专注于自己最擅长的：创建人们喜爱的应用程序。Hired—Android开发者的招聘平台国外版的100Offer LIBRARIES &amp; CODELightcycleMaterialColorsAppMaterialColorsApp 是一个方便的Mac小应用程序，让您可以快速访问标准的材料设计调色板。LandscapeVideoCamera非常强大的android 视频录制库，可以选择视频尺寸以及视频质量，只允许横屏录制。 新闻Android Experiments I/O 挑战赛去年夏天谷歌开发者社区启动了 Android Experiments ：一个用于展示创新性 Android 作品的项目。所有开发者都可以提交你的创意作品，通过后将加入到网站收录中。Fragmented Podcast 更新了 – TSHIRTS!发布限量版的Fragmented T-ShirtAndroid Studio 2.1 Preview 4 可用了Google在canary渠道推送了Android Studio 2.1 Preview 4，修复了很多bug。 工具Google新的 Accessibility Scanner全新的Accessibility Scanner应用程序允许你检查潜在的问题从而改进你的应用程序。它在Play商店免费下载，但目前它仅限于Android 6.0设备。","categories":[{"name":"Android移动开发技术周报","slug":"Android移动开发技术周报","permalink":"http://logan62334.github.io/categories/Android移动开发技术周报/"}],"tags":[{"name":"Android移动开发技术周报","slug":"Android移动开发技术周报","permalink":"http://logan62334.github.io/tags/Android移动开发技术周报/"}]},{"title":"西瓜理财APP开源库的使用","slug":"Android-西瓜理财APP开源库的使用","date":"2016-03-29T23:15:55.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/03/29/Android-西瓜理财APP开源库的使用/","link":"","permalink":"http://logan62334.github.io/2016/03/29/Android-西瓜理财APP开源库的使用/","excerpt":"","text":"接着上篇说，在Android开发过程中，我们经常会遇到是否需要自己造轮子的问题，我个人认为在开发周期有限人员配置有限的情况下，还是多参考些开源库比较好，在时间空闲的时候也鼓励大家为开源事业贡献一部分自己的力量当然看个人喜好啦~接下来讲讲在开发西瓜理财APP的过程中是如何使用和寻找开源库的。 在讲之前首先学会如何科学的上网，这里我想说一下网上有很多教程和工具教你如何姿势正确的上网例如赛风、ShadowsocksX等但是经常会出现连接不稳定而且最重要的是要想稳定连接必须付费！其实这里有个简单实用的技巧可以轻松访问国外网站：修改本机的hosts。这里推荐一个地址：http://htcui.com/4938.html 这里会定期更新，有点遗憾就是不能看YouTube视频但是网站可以访问，不过对于我们开发来说已经足够了。 常用的网站1、https://github.com/这个就不多说了，没注册的赶紧去注册！2、http://www.jcodecraeer.com/plus/list.php?tid=31泡在网上的日子这个网站也分享了很多优秀的开源项目，而且都带有效果图3、http://www.mobile-open.com/这个网站根据不同类型和用途分的很细，Android和IOS都有4、http://android-arsenal.com/Android军械库，顾名思义各种神器任你挑任你选5、http://www.23code.com/这个也是定期会更新一批好的开源项目6、http://p.codekk.com/codekk的开源项目集合 这样的网站太多了，最后分享两个各种API服务的聚合网站1、http://www.devstore.cn/2、http://apistore.baidu.com/ 最后讲讲使用开源库应该注意的一些地方1、选择开源库的时候一定不要选择那些已经停止更新的库，尽量选择star和fork人数多的库，并且还在更新中。 2、有些开源项目虽然很好但是功能太多如果直接引入，会带来太多不必要的代码从而增大apk大小，所以建议是先学习一下然后提取对自己有用的那一部分。 3、如果自己的工程中引入了太多的开源库，那么建议在公司自己的服务器上搭建一套私服环境，通过gradle和Nexus搭配这样会使编译速度加快许多因为不用每次到外网去下载这些开源库了。 4、一个项目中不要引入过多的开源库，引入的过多会使编译变慢，apk包变大，编译冲突等问题。 另外希望大家能够将自己使用开源库的心得和遇见的问题贡献出来互相学习！","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/tags/Android笔记/"}]},{"title":"西瓜理财APP用到的开源库和工具整理","slug":"西瓜理财APP用到的开源库和工具整理","date":"2016-03-17T22:08:15.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/03/17/西瓜理财APP用到的开源库和工具整理/","link":"","permalink":"http://logan62334.github.io/2016/03/17/西瓜理财APP用到的开源库和工具整理/","excerpt":"","text":"今天来聊聊我之前负责过的一款APP——西瓜理财Android版本所用到的一些开源库和开发工具，不过由于微信公众号不支持外链所以就不贴地址了。 Android studio 插件1、Android ButterKnife Zelezny这是著名的Jake Wharton黄油刀插件，用过的都说好，连注解都不用亲自写了，效率直线提升。2、GsonFormat这个插件可以将mobileapi返回的json数据直接转换为实体类，省去了我们写一大堆的字段属性和Getter、Setter方法所花费的时间。3、Android Parcelable code generator大家如果用到Parcelable来序列化实体类的话，将会面临比Serializable复杂的多的步骤所以通过使用这个插件来帮我们一键生成对应的方法。另外：需要注意的是当有新的属性加入的时候记得重新生成一次不然会出现序列化错误。4、.ignore这个是配合Git控制来忽略一些本地配置文件和不需要同步的代码文件。5、Genymotion这个就不必多说了，用过的都说好。 第三方库1、Nuwa最近议论最多的热修复框架，这只是其中一种实现方案。2、Umeng用来做APP统计分析的平台，不过建议大家以后可以考虑阿里最近推出的移动应用数据分析平台。3、诸葛IO一款精细化数据分析的工具，重点在移动用户行为分析不过由于后期数据激增开始收费了所以放弃了。4、Cobub Razor号称私有版的友盟，因为考虑到友盟统计的数据不太能真实反映用户情况，所以我们决定搭建一套自己的数据采集分析系统但考虑到时间成本所以采用了这个开源项目，省去了设计各种上传策略的时间。5、极光推送这个要说一点的是注意官网的各种cpu架构下的so文件更新，一定要全都加入工程不然会在个别机型上报本地库加载异常的错误。6、Fresco这个是Facebook最近推出的一款图片加载框架，对OOM的问题做了特殊优化。7、sharesdk第三方分享首选8、ButterKnife都说程序员都是比较懒的，什么事情都想着让程序自动化帮忙减轻工作量，这个开源库可以让我们从大量的findViewById()和setonclicktListener()解放出来，最令人兴奋的是其对性能的影响微乎其微！9、Gson谷歌GSON这个Java类库可以把Java对象转换成JSON，也可以把JSON字符串转换成一个相等的Java对象。Gson支持任意复杂Java对象包括没有源代码的对象。10、EventBus在编程过程中，当我们想通知其他组件某些事情发生时，我们通常使用观察者模式，正是因为观察者模式非常常见，所以在jdk1.5中已经帮助我们实现了观察者模式，我们只需要简单的继承一些类就可以快速使用观察者模式，在Android中也有一个类似功能的开源库EventBus，可以很方便的帮助我们实现观察者模式，另外注意：EventBus有好几款开源库，github上有人专门做过对比各个库的优缺点大家可以参考。11、NetroidNetroid是一个基于Volley实现的Android Http库，提供执行网络请求、缓存返回结果、批量图片加载、大文件断点下载的常见Http交互功能，致力于避免每个项目重复开发基础Http功能，实现显著地缩短开发周期的愿景。12、腾讯X5浏览内核腾讯X5浏览服务由QQ浏览器团队出品，致力于优化移动端webview体验的整套解决方案，使用QQ浏览器X5内核SDK和X5云端服务，解决移动端webview使用过程中出现的一切问题，优化用户的浏览体验，同时腾讯还将持续提供后续的更新和优化，为开发者提供最新最优秀的功能和服务。 其他开发工具1、蒲公英其实这种应用内侧分发的平台很多，之所以选蒲公英是因为他有mac版的客户端上传比较方便，而且还有对于的gradle代码用来实现自动化打包发布。2、Charles这个是一款功能比较强大的抓包工具，在跟mobileapi对接和测试中非常高效。3、LeakCanary强烈推荐，帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。4、Logger让开发调试效率提高至少300%而且心情愉悦的Log神器。 结语今天就写到这里吧，以后会定期推荐一些好的开源库和工具，详情戳公众号的菜单栏。","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/tags/Android笔记/"}]},{"title":"西瓜小贴士图片浏览功能实现思路","slug":"Android-西瓜小贴士图片浏览功能实现思路","date":"2016-03-07T23:04:02.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/03/07/Android-西瓜小贴士图片浏览功能实现思路/","link":"","permalink":"http://logan62334.github.io/2016/03/07/Android-西瓜小贴士图片浏览功能实现思路/","excerpt":"","text":"最近翻到前段时间的一版设计稿，如下图这样的一个效果，当时都已经实现了但后来由于需求变更所以……没能让它和广大用户见面，但感觉这种效果还是不错的所以拿出来分享一下。 功能需求1、右上角是页数指示器2、左右两个操作按钮要求触摸时时消失3、可以左右滑动 实现思路1、图片预存在本地通过Fresco来加载2、滑动效果通过ViewPager+fragment实现 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends AppCompatActivity &#123; private static final Integer[] IMAGES = new Integer[] &#123; R.mipmap.tip1,R.mipmap.tip2,R.mipmap.tip3,R.mipmap.tip4,R.mipmap.tip5,R.mipmap.tip6,R.mipmap.tip7,R.mipmap.tip8 &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Fresco.initialize(this); final ViewPager pager = (ViewPager) findViewById(R.id.pager); PageIndicator mPageIndicator= (PageIndicator) findViewById(R.id.indicator); ImageView ivLeft= (ImageView) findViewById(R.id.ivLeft); ImageView ivRight= (ImageView) findViewById(R.id.ivRight); ivLeft.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; pager.setCurrentItem(pager.getCurrentItem()-1); &#125; &#125;); ivRight.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; pager.setCurrentItem(pager.getCurrentItem()+1); &#125; &#125;); SlidePagerAdapter pagerAdapter = new SlidePagerAdapter(getSupportFragmentManager()); // set pictures pagerAdapter.addAll(Arrays.asList(IMAGES)); pager.setAdapter(pagerAdapter); pager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); mPageIndicator.setViewPager(pager); &#125; SlidePageFragment.java 1234567891011121314151617181920212223242526272829public class SlidePageFragment extends Fragment &#123; private static final String PIC_URL = &quot;slidepagefragment.picurl&quot;; public static SlidePageFragment newInstance(@NonNull final int picUrl) &#123; Bundle arguments = new Bundle(); arguments.putInt(PIC_URL, picUrl); SlidePageFragment fragment = new SlidePageFragment(); fragment.setArguments(arguments); return fragment; &#125; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_slide_page, container, false); SimpleDraweeView view = (SimpleDraweeView) rootView.findViewById(R.id.pic); Bundle arguments = getArguments(); if (arguments != null) &#123; int url = arguments.getInt(PIC_URL); view.setBackgroundResource(url); &#125; return rootView; &#125;&#125; SlidePagerAdapter.java 123456789101112131415161718192021public class SlidePagerAdapter extends FragmentStatePagerAdapter &#123; private List&lt;Integer&gt; picList = new ArrayList&lt;&gt;(); public SlidePagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int i) &#123; return SlidePageFragment.newInstance(picList.get(i)); &#125; @Override public int getCount() &#123; return picList.size(); &#125; public void addAll(List&lt;Integer&gt; picList) &#123; this.picList = picList; &#125;&#125; 详细文件请访问：https://github.com/logan62334/Gallery","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android 图片浏览","slug":"Android-图片浏览","permalink":"http://logan62334.github.io/tags/Android-图片浏览/"}]},{"title":"Android冷启动时间优化","slug":"Android-冷启动时间优化","date":"2016-03-03T13:12:49.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/03/03/Android-冷启动时间优化/","link":"","permalink":"http://logan62334.github.io/2016/03/03/Android-冷启动时间优化/","excerpt":"","text":"冷启动时间是指当用户点击你的app那一刻到系统调用Activity.onCreate()之间的时间段。在这个时间段内，WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局，而通常情况下这个默认背景是黑色或者白色所以如果不加以优化会让用户感觉到app很卡很慢。 知道了Android冷启动时间的原理之后，就可以通过一些小技巧来对冷启动时间进行优化，从而让你app加载变得”快“一些（视觉体验上的快）。我是通过使用app闪屏页的图片来做为windowBackground这样可以传达企业的形象。 1、为启动的Activity自定义一个Theme 123&lt;style name=&quot;AppTheme.Launcher&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/window_background&lt;/item&gt;&lt;/style&gt; 2、将新的Theme应用到设置到 AndroidManifest.xml 中 12345678&lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot;@style/AppTheme.Launcher&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 3、由于给MainActivity设置了一个新的Theme，这样做会覆盖原来的Theme，所以在MainActivity中需要设置回原来的Theme 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // Make sure this line comes before calling super.onCreate(). setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); &#125;&#125; 最后推荐大家一个开源项目也是用来实现冷启动优化的不过是MaterialDesign风格的：https://github.com/DreaminginCodeZH/MaterialColdStart","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android 冷启动 启动黑屏","slug":"Android-冷启动-启动黑屏","permalink":"http://logan62334.github.io/tags/Android-冷启动-启动黑屏/"}]},{"title":"Android应用崩溃(Crash)日志报告","slug":"Android-应用崩溃-Crash-日志报告","date":"2016-03-02T12:19:39.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/03/02/Android-应用崩溃-Crash-日志报告/","link":"","permalink":"http://logan62334.github.io/2016/03/02/Android-应用崩溃-Crash-日志报告/","excerpt":"","text":"我们在开发应用的过程中不可避免的会遇到各种Crash，今天分享一下如何姿势正确的处理这些Crash来提高我们的开发效率。 对于应用的Crash处理分为测试环境和生产环境。 1、测试环境在开发过程中为了方便快速定位崩溃所发生的代码，要求我们能在崩溃的同时将日志打印出来，最好以直观的界面显示。这里推荐大家一个开源项目：CustomActivityOnCrashgithub地址：https://github.com/Ereza/CustomActivityOnCrash 2、生产环境当应用发布上线就不能给用户显示这样的界面了所以要用一种用户比较能接受的方式处理。在Application类中配置如下： 123456789101112/** * 初始化程序崩溃捕捉处理 */ protected void initCrashHandler() &#123; if (BuildConfig.isDebug) &#123; CustomActivityOnCrash.install(this); &#125; else &#123; CrashHandler handler = CrashHandler.getInstance(); handler.init(getApplicationContext()); Thread.setDefaultUncaughtExceptionHandler(handler); &#125; &#125; CrashHandler类文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215 public class CrashHandler implements UncaughtExceptionHandler &#123; /** Debug Log tag*/ public static final String TAG = &quot;CrashHandler&quot;; /** 是否开启日志输出,在Debug状态下开启, * 在Release状态下关闭以提示程序性能 * */ public static final boolean DEBUG = false; /** 系统默认的UncaughtException处理类 */ private UncaughtExceptionHandler mDefaultHandler; /** CrashHandler实例 */ private static CrashHandler INSTANCE; /** 程序的Context对象 */ private Context mContext; /** 使用Properties来保存设备的信息和错误堆栈信息*/ private Properties mDeviceCrashInfo = new Properties(); private static final String VERSION_NAME = &quot;versionName&quot;; private static final String VERSION_CODE = &quot;versionCode&quot;; private static final String STACK_TRACE = &quot;STACK_TRACE&quot;; /** 错误报告文件的扩展名 */ private static final String CRASH_REPORTER_EXTENSION = &quot;.cr&quot;; /** 保证只有一个CrashHandler实例 */ private CrashHandler() &#123;&#125; /** 获取CrashHandler实例 ,单例模式*/ public static CrashHandler getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new CrashHandler(); &#125; return INSTANCE; &#125; /** * 初始化,注册Context对象, * 获取系统默认的UncaughtException处理器, * 设置该CrashHandler为程序的默认处理器 * @param ctx */ public void init(Context ctx) &#123; mContext = ctx; mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); &#125; /** * 当UncaughtException发生时会转入该函数来处理 */ @Override public void uncaughtException(Thread thread, Throwable ex) &#123; if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123; //如果用户没有处理则让系统默认的异常处理器来处理 mDefaultHandler.uncaughtException(thread, ex); &#125; else &#123; //Sleep一会后结束程序 try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; Log.e(TAG, &quot;Error : &quot;, e); &#125; android.os.Process.killProcess(android.os.Process.myPid()); System.exit(10); &#125; &#125; /** * 自定义错误处理,收集错误信息 * 发送错误报告等操作均在此完成. * 开发者可以根据自己的情况来自定义异常处理逻辑 * @param ex * @return true:如果处理了该异常信息;否则返回false */ private boolean handleException(Throwable ex) &#123; if (ex == null) &#123; Log.w(TAG, &quot;handleException --- ex==null&quot;); return true; &#125; final String msg = ex.getLocalizedMessage(); if(msg == null) &#123; return false; &#125; //使用Toast来显示异常信息 new Thread() &#123; @Override public void run() &#123; Looper.prepare(); Toast toast = Toast.makeText(mContext, &quot;程序出错，即将退出&quot;, Toast.LENGTH_LONG); toast.setGravity(Gravity.CENTER, 0, 0); toast.show();// MsgPrompt.showMsg(mContext, &quot;程序出错啦&quot;, msg+&quot;\\n点确认退出&quot;); Looper.loop(); &#125; &#125;.start(); //收集设备信息 collectCrashDeviceInfo(mContext); //保存错误报告文件 saveCrashInfoToFile(ex); //发送错误报告到服务器 //sendCrashReportsToServer(mContext); return true; &#125; /** * 在程序启动时候, 可以调用该函数来发送以前没有发送的报告 */ public void sendPreviousReportsToServer() &#123; sendCrashReportsToServer(mContext); &#125; /** * 把错误报告发送给服务器,包含新产生的和以前没发送的. * @param ctx */ private void sendCrashReportsToServer(Context ctx) &#123; String[] crFiles = getCrashReportFiles(ctx); if (crFiles != null &amp;&amp; crFiles.length &gt; 0) &#123; TreeSet&lt;String&gt; sortedFiles = new TreeSet&lt;String&gt;(); sortedFiles.addAll(Arrays.asList(crFiles)); for (String fileName : sortedFiles) &#123; File cr = new File(ctx.getFilesDir(), fileName); postReport(cr); cr.delete();// 删除已发送的报告 &#125; &#125; &#125; private void postReport(File file) &#123; // TODO 发送错误报告到服务器 &#125; /** * 获取错误报告文件名 * @param ctx * @return */ private String[] getCrashReportFiles(Context ctx) &#123; File filesDir = ctx.getFilesDir(); FilenameFilter filter = new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; return name.endsWith(CRASH_REPORTER_EXTENSION); &#125; &#125;; return filesDir.list(filter); &#125; /** * 保存错误信息到文件中 * @param ex * @return */ private String saveCrashInfoToFile(Throwable ex) &#123; Writer info = new StringWriter(); PrintWriter printWriter = new PrintWriter(info); ex.printStackTrace(printWriter); Throwable cause = ex.getCause(); while (cause != null) &#123; cause.printStackTrace(printWriter); cause = cause.getCause(); &#125; String result = info.toString(); printWriter.close(); mDeviceCrashInfo.put(&quot;EXEPTION&quot;, ex.getLocalizedMessage()); mDeviceCrashInfo.put(STACK_TRACE, result); try &#123; //long timestamp = System.currentTimeMillis(); Time t = new Time(&quot;GMT+8&quot;); t.setToNow(); // 取得系统时间 int date = t.year * 10000 + t.month * 100 + t.monthDay; int time = t.hour * 10000 + t.minute * 100 + t.second; String fileName = &quot;crash-&quot; + date + &quot;-&quot; + time + CRASH_REPORTER_EXTENSION; FileOutputStream trace = mContext.openFileOutput(fileName, Context.MODE_PRIVATE); mDeviceCrashInfo.store(trace, &quot;&quot;); trace.flush(); trace.close(); return fileName; &#125; catch (Exception e) &#123; Log.e(TAG, &quot;an error occured while writing report file...&quot;, e); &#125; return null; &#125; /** * 收集程序崩溃的设备信息 * * @param ctx */ public void collectCrashDeviceInfo(Context ctx) &#123; try &#123; PackageManager pm = ctx.getPackageManager(); PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES); if (pi != null) &#123; mDeviceCrashInfo.put(VERSION_NAME, pi.versionName == null ? &quot;not set&quot; : pi.versionName); mDeviceCrashInfo.put(VERSION_CODE, &quot;&quot;+pi.versionCode); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; Log.e(TAG, &quot;Error while collect package info&quot;, e); &#125; //使用反射来收集设备信息.在Build类中包含各种设备信息, //例如: 系统版本号,设备生产商 等帮助调试程序的有用信息 //具体信息请参考后面的截图 Field[] fields = Build.class.getDeclaredFields(); for (Field field : fields) &#123; try &#123; field.setAccessible(true); mDeviceCrashInfo.put(field.getName(), &quot;&quot;+field.get(null)); if (DEBUG) &#123; Log.d(TAG, field.getName() + &quot; : &quot; + field.get(null)); &#125; &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error while collect crash info&quot;, e); &#125; &#125; &#125;&#125;","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android 应用崩溃 日志分析","slug":"Android-应用崩溃-日志分析","permalink":"http://logan62334.github.io/tags/Android-应用崩溃-日志分析/"}]},{"title":"Git简易指南","slug":"Git-简易指南","date":"2016-03-01T22:48:52.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/03/01/Git-简易指南/","link":"","permalink":"http://logan62334.github.io/2016/03/01/Git-简易指南/","excerpt":"","text":"今天来分享一下我在使用Git的过程中经常用到的一些命令： 1、创建新仓库 1git init 2、检出仓库 1git clone username@host:/path/to/repository 3、添加与提交 12git add *git commit -m &quot;代码提交信息&quot; 4、推送改动 1git push origin master 5、创建分支 1git checkout -b feature_x 6、切换分支 1git checkout master 7、删除本地分支 1git branch -d feature_x 8、删除远程分支 1git push origin :feature_x 9、将分支推送到远端仓库 1git push origin &lt;branch&gt; 10、更新你的本地仓库至最新改动 1git pull 11、合并其他分支到你的当前分支 1git merge &lt;branch&gt;","categories":[{"name":"Git","slug":"Git","permalink":"http://logan62334.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://logan62334.github.io/tags/Git/"}]},{"title":"WebView内存泄露终结解决方案","slug":"Android-WebView内存泄露终结解决方案","date":"2016-02-28T22:46:50.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/02/28/Android-WebView内存泄露终结解决方案/","link":"","permalink":"http://logan62334.github.io/2016/02/28/Android-WebView内存泄露终结解决方案/","excerpt":"","text":"但凡是做Android开发的相信都对webview不会陌生，而且也对系统自带的webview本身存在的问题也是怨念很久了，一方面是本身对js的支持不是很好另外一方面就是经常被人诟病的内存泄露了。 不知道各位遇到同样问题的朋友是怎么解决的，网上也有很多解析和方案但至少在我的项目中是没任何效果的，今天我就分享一下我最终是怎么解决这些问题的（其实是很蠢的一个办法）。 需求背景：需要一个带有加载进度条的webview来正常的显示合作方和自己的web页面。 1、解决webview对一些js的支持： 12用JsBridge代替系统原生的webview，github地址：https://github.com/lzyzsd/JsBridge 2、解决webview内存泄露： 12345678910111213141516171819202122232425262728293031323334353637@Bind(R.id.pb) ProgressBar pb; @Bind(R.id.mWebView) BridgeWebView mWebView; pb.setMax(100); mWebView.setWebChromeClient(new WebViewClient()); mWebView.loadUrl(strWebsite); private class WebViewClient extends WebChromeClient &#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; try &#123; pb.setProgress(newProgress); if (newProgress == 100) &#123; pb.setVisibility(View.GONE); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; super.onProgressChanged(view, newProgress); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); try &#123; if (mWebView != null) &#123; mWebView.removeAllViews(); mWebView.destroy(); mWebView = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 最后介绍大家一个用来检测应用内存泄露的工具：leakcanarygithub地址：https://github.com/square/leakcanary","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"webview","slug":"webview","permalink":"http://logan62334.github.io/tags/webview/"}]},{"title":"Activity启动后EditText是否自动弹出输入法虚拟键盘的问题","slug":"Activity启动后EditText是否自动弹出输入法虚拟键盘的问题","date":"2016-02-27T17:54:53.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/02/27/Activity启动后EditText是否自动弹出输入法虚拟键盘的问题/","link":"","permalink":"http://logan62334.github.io/2016/02/27/Activity启动后EditText是否自动弹出输入法虚拟键盘的问题/","excerpt":"","text":"在开发过程中，我们经常会遇到Activity中包含EditText控件时会自动弹出虚拟键盘的情况，这是由于EditText自动获得焦点的缘故，只要让EditText失去焦点就行了，解决办法如下： 1、在Manifest.xml文件中相应的Activity下添加如下代码： 1android:windowSoftInputMode=&quot;stateHidden&quot; 2、让EditText失去焦点，用EditText的clearFocus： 12EditText edt = (EditText)findViewById(R.id.edt);edt.clearFocus(); 3、强制隐藏Android输入法窗口： 123EditText edt = (EditText)findViewById(R.id.edt); InputMethodManager imm = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(edt.getWindowToken(), 0); 4、要求EditText始终不弹出虚拟键盘： 12EditText edt = (EditText)findViewById(R.id.edt); edt.setInputType(InputType.TYPE_NULL); 但有时我们确实是想让EditText自动获得焦点并弹出软键盘，在设置了EditText自动获得焦点后，软件盘不会弹出。注意：此时是由于刚跳到一个新的界面，界面未加载完全而无法弹出软键盘。此时应该适当的延迟弹出软键盘，如500毫秒（保证界面的数据加载完成，如果500毫秒仍未弹出，则延长至1000毫秒）。 1、可以在EditText后面加上一段代码： 123456789Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; public void run() &#123; InputMethodManager inputManager = (InputMethodManager) editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputManager.showSoftInput(editText, 0); &#125; &#125;, 500); 2、给activity配置加入属性： 1android:windowSoftInputMode=&quot;adjustResize&quot;","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android布局UI","slug":"Android布局UI","permalink":"http://logan62334.github.io/tags/Android布局UI/"}]},{"title":"Android持续集成技术实践","slug":"Android持续集成技术实践","date":"2016-02-02T16:08:59.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/02/02/Android持续集成技术实践/","link":"","permalink":"http://logan62334.github.io/2016/02/02/Android持续集成技术实践/","excerpt":"","text":"背景 随着业务需求的演进，工程的复杂度会逐渐增加，自动化的践行日益强烈。事实上，工程的自动化一直是我们努力追求的目标，能有效提高我们的生产效率，最大化减少人为出错的概率，实现一些复杂的业务需求应变。 以我现在的公司为例，我们有22个渠道包，而且分为测试环境和生产环境，新的迭代开始除去要经常给测试人员直接烧测试版APP偶尔还会被商务和运营打断要求新增一个渠道包。尤其临近发版的一周，几乎每天都要新版本。这样的话，有两方面的影响：第一，打断了开发人员的开发进度；第二，开发人员打包效率低下。 要解决这个问题，必须实现移动端应用的自动化构建。具体说来就是，使用持续集成（CI）系统jenkins，自动检测并拉取Git上的最新代码，自动打包成不同的渠道apk，自动上传到内测分发平台蒲公英上和自建的FTP服务器上。（接下来，测试人员只要打开一个（或多个）固定的网址，扫描一下二维码，就能下载最新的版本了…） 环境 因为公司内网的服务器都是Windows操作系统，所以下面的操作都是以Windows为例，无论是哪个操作系统，jenkins的配置是一样的。 安装Jenkins 官网地址： http://jenkins-ci.org/，具体安装过程就不详写了跟平常装软件没什么区别。默认访问 http://localhost:8080/ , 可进入jenkins配置页面。 安装Jenkins相关插件 点击系统管理&gt;管理插件&gt;可选插件，可搜索以下插件安装 git插件(GIT plugin) ssh插件(SSH Credentials Plugin) Gradle插件(Gradle plugin) - android专用 注： 这里要用VPN或者修改系统的hosts文件才可以搜索到插件； 还有就是Windows中要装好JDK、Git、Gradle的环境。 装好后的效果图： 新建Job 主页面，新建 -&gt; 构建一个自由风格的软件项目即可。 配置git仓库 如果安装了git插件，在源码管理会出现Git，选中之后： 配置自动拉取最新代码 在构建触发器中，有两种自动拉取代码并编译的策略: 设置Poll SCM，设置定时器，定时检查代码更新，有更新则编译，否则不编译。 也可以设置Build periodically，周期性的执行编译任务。 配置gradle 如果安装gradle插件成功的话，应该会出现下图的Invoke Gradle script，配置一下: 这样，就能自动在project下的app的build/outputs/apk下生成相应的apk. 因为要区分测试环境和生产环境，所以我建了两个任务分别对应git上的主分支和子分支： FTP服务器搭建： 如果不会利用IIS搭建FTP的同学可以自行百度这里就不详细介绍了，记得把FTP根路径指向编译结果的目录：D:\\Jenkins\\jobs\\XXForAndroidTest\\workspace\\app\\build\\outputs\\apk 如果编译失败，请检查以下问题： 确保gradle、git、jdk的环境变量都配好 找不到local.properties中sdk定义，因为一般来说local.properties不会添加到版本库。 还有就是子项目中build.gradle的签名秘钥的路径问题 关于local.properties的定义： sdk.dir=xx/xx/android-sdk 再编译一般就会编译成功，当然当那些第三方库需要重新下载的话，编译可能会很慢。 总结一下 经过以上的折腾，以后终于可以彻底解放开发人员的双手去专心写代码了，我们在以后的工作中也要尽量去把精力放在业务上面提高工作效率。","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android自动化构建","slug":"Android自动化构建","permalink":"http://logan62334.github.io/tags/Android自动化构建/"}]},{"title":"Android热修复技术实践","slug":"Android热修复技术实践","date":"2016-02-01T17:54:53.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2016/02/01/Android热修复技术实践/","link":"","permalink":"http://logan62334.github.io/2016/02/01/Android热修复技术实践/","excerpt":"","text":"背景我所在的公司是一家互联网金融领域的初创型公司，这类公司向来都是奉行快速迭代敏捷开发，所以基本我们的APP两周一个迭代有时候工期比较紧可能一周一个迭代，在缺乏专业QA人员的情况下单凭团队内其他做产品和运营的小伙伴的用最原始的人工点击测试下难免会遗漏一些潜在bug，于是当我们的应用发布之后，经过十多万用户的随机点击和产生的随机数据突然发现了一个严重bug需要进行紧急修复的时候公司各方就会忙得焦头烂额：还原bug、修复、重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。 这时候就产生了一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布App，不再需要用户重新下载，覆盖安装？ 虽然Android系统并没有提供这个技术，但是很幸运的告诉大家，答案是：可以的！而且在最初由QQ空间团队提出的热补丁动态修复技术方案后各大公司也都纷纷效仿，网上也出现了很多开源的解决方案。 实际案例让我们先来看一下网上都有哪些解决方案：XposeddexposedAndFixDroidFixDynamicAPKNuwa根据其描述，原理都来自：Android dex分包方案（http://codecloud.net/android-hot-load-6575.html）。这里就不对这些框架做过多对比了，因为原理都一致，实现的代码可能有些差异并不是特别大。这里我就先讲讲我是怎么去对热修复框架进行选型的吧，大家也看到了能实现这个功能的开源框架最近出了很多但并不是每个都适合我们现在的应用，Xposed它因为需要手机获得root权限才能生效所以首先pass。dexposed和AndFix是阿里基于Xposed的思路沉淀出的两套热修复解决方案，但是经过实际测试后发现它由于缺少动态库so文件所以在大部分机型上都不能正常运行：在其官方github上有类似很多的问题所以也只能放弃虽然它的补丁生成器做的很完善但是然并卵……DynamicAPK这个是携程最新公布的一个解决方案，但是由于它功能实在过于庞大而且其主要功能是用来做多apk动态加载的所以对热修复这块并不是重点实现。最后我把注意力放在了Nuwa上，但是经过实际部署测试后发现总是编译出错于是翻看了github上的issue列表发现有很多人也遇到了类似问题最后通过排除掉Nuwa.init所在的类后就fix好了，原来是Nuwa所在的class文件是无法进行修复的，所以在这个文件中尽量只写一些初始化代码和配置保证不会出问题。然后接下来遇到的就是补丁包生成不了的窘境了……继续google：https://github.com/jasonross/Nuwa/issues/23在这篇文章中找到了答案。好了接下来就是考虑到我们有20个渠道并且可能出现不同版本的补丁包的情况了，于是我申请了一台ftp服务器专门用来做为每次补丁包的存放路径，在这个路径下：这样在客户端通过每次拉取config配置文件的api进行判断当前版本是否需要打补丁，如果需要则根据当前渠道号从对应的ftp服务器下载，当用户第二次打开应用的时候就会load这个patch，这样就在用户毫不知情的情况下完成了问题修复。","categories":[{"name":"Android新技术实践","slug":"Android新技术实践","permalink":"http://logan62334.github.io/categories/Android新技术实践/"}],"tags":[{"name":"Android 热修复","slug":"Android-热修复","permalink":"http://logan62334.github.io/tags/Android-热修复/"}]},{"title":"Android实现APP开屏广告","slug":"Android 实现APP开屏广告","date":"2016-01-02T08:54:53.000Z","updated":"2019-02-26T06:39:44.790Z","comments":true,"path":"2016/01/02/Android 实现APP开屏广告/","link":"","permalink":"http://logan62334.github.io/2016/01/02/Android 实现APP开屏广告/","excerpt":"","text":"代码详见：https://github.com/logan62334/StartupAdPage 功能点： 实现打开应用从moblieapi获取广告信息并存储在本地； 每次APP打开显示上一次缓存下来的广告； 可以控制广告停留时间和跳转页面 很容易扩展","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android 开屏广告","slug":"Android-开屏广告","permalink":"http://logan62334.github.io/tags/Android-开屏广告/"}]},{"title":"Android实现PopupWindow背景半透明（兼容方案）","slug":"Android实现PopupWindow背景半透明（兼容方案）","date":"2015-12-27T11:37:42.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2015/12/27/Android实现PopupWindow背景半透明（兼容方案）/","link":"","permalink":"http://logan62334.github.io/2015/12/27/Android实现PopupWindow背景半透明（兼容方案）/","excerpt":"","text":"大家想必对PopupWindow不会很陌生吧，我们在开发中经常会遇到要求使其背景半透明的需求，但网上的很多解决方案只能是在大部分机型上满足要求，像华为这样的机型就会发现我们原来设置的背景变暗效果的代码并没有起效果。这里我贴出最终的兼容方案： View contentView; LayoutInflater mLayoutInflater = LayoutInflater.from(activity); contentView = mLayoutInflater.inflate(R.layout.layout_popupwindow, null); pop = new PopupWindow(contentView, ViewGroup.LayoutParams.MATCH_PARENT, (int) context.getResources().getDimension(R.dimen.y568)); TextView tvTitle = (TextView) contentView.findViewById(R.id.text); tvTitle.setText(strTitle); ListView listView = (ListView) contentView.findViewById(R.id.list); // 产生背景变暗效果 WindowManager.LayoutParams lp = activity.getWindow() .getAttributes(); lp.alpha = 0.4f; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); activity.getWindow().setAttributes(lp); pop.setTouchable(true); pop.setFocusable(true); pop.setBackgroundDrawable(new BitmapDrawable()); pop.setOutsideTouchable(true); pop.showAtLocation(contentView, Gravity.BOTTOM, 0, 0); pop.update(); pop.setOnDismissListener(new PopupWindow.OnDismissListener() { // 在dismiss中恢复透明度 public void onDismiss() { WindowManager.LayoutParams lp = activity.getWindow() .getAttributes(); lp.alpha = 1f; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); activity.getWindow().setAttributes(lp); } }); listView.setOnItemClickListener(onItemClickListener); listView.setAdapter(adapter); 注：特别是下面几行代码 // 产生背景变暗效果 WindowManager.LayoutParams lp = activity.getWindow() .getAttributes(); lp.alpha = 0.4f; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); activity.getWindow().setAttributes(lp); pop.setTouchable(true); pop.setFocusable(true); pop.setBackgroundDrawable(new BitmapDrawable()); pop.setOutsideTouchable(true); pop.showAtLocation(contentView, Gravity.BOTTOM, 0, 0); pop.update(); pop.setOnDismissListener(new PopupWindow.OnDismissListener() { // 在dismiss中恢复透明度 public void onDismiss() { WindowManager.LayoutParams lp = activity.getWindow() .getAttributes(); lp.alpha = 1f; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); activity.getWindow().setAttributes(lp); } }); 网上很多方案都要求加下面这两行代码，但其实加上反而会影响华为这种机型的显示效果 ColorDrawable dw = new ColorDrawable(-00000); popupWindow.setBackgroundDrawable(dw); *** ![FullStackEngineer的公众号，更多分享](https://github.com/logan62334/ImageArchive/raw/master/weixin/weixin.jpg)","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android布局UI","slug":"Android布局UI","permalink":"http://logan62334.github.io/tags/Android布局UI/"}]},{"title":"Android实现button一边圆角一边直角","slug":"Android实现button一边圆角一边直角","date":"2014-12-22T10:04:02.000Z","updated":"2019-02-26T06:39:44.794Z","comments":true,"path":"2014/12/22/Android实现button一边圆角一边直角/","link":"","permalink":"http://logan62334.github.io/2014/12/22/Android实现button一边圆角一边直角/","excerpt":"","text":"Android中要实现如下图的效果：这个要在真机中才能看出效果！！switch_button_left_checked.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;!-- 填充的颜色：这里设置背景透明 --&gt; &lt;solid android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 边框的颜色 ：不能和窗口背景色一样 --&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:bottomLeftRadius=&quot;5dip&quot; android:bottomRightRadius=&quot;0dip&quot; android:topLeftRadius=&quot;5dip&quot; android:topRightRadius=&quot;0dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:bottom=&quot;5dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot; android:top=&quot;5dp&quot; /&gt; &lt;/shape&gt; switch_button_left.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;!-- 填充的颜色：这里设置背景透明 --&gt; &lt;solid android:color=&quot;#00000000&quot; /&gt; &lt;!-- 边框的颜色 ：不能和窗口背景色一样 --&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:bottomLeftRadius=&quot;5dip&quot; android:bottomRightRadius=&quot;0dip&quot; android:topLeftRadius=&quot;5dip&quot; android:topRightRadius=&quot;0dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:bottom=&quot;5dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot; android:top=&quot;5dp&quot; /&gt; &lt;/shape&gt; switch_button_right_checked.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;!-- 填充的颜色：这里设置背景透明 --&gt; &lt;solid android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 边框的颜色 ：不能和窗口背景色一样 --&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:bottomLeftRadius=&quot;0dip&quot; android:bottomRightRadius=&quot;5dip&quot; android:topLeftRadius=&quot;0dip&quot; android:topRightRadius=&quot;5dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:bottom=&quot;5dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot; android:top=&quot;5dp&quot; /&gt; &lt;/shape&gt; switch_button_right.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;!-- 填充的颜色：这里设置背景透明 --&gt; &lt;solid android:color=&quot;#00000000&quot; /&gt; &lt;!-- 边框的颜色 ：不能和窗口背景色一样 --&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#ff304a&quot; /&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:bottomLeftRadius=&quot;0dip&quot; android:bottomRightRadius=&quot;5dip&quot; android:topLeftRadius=&quot;0dip&quot; android:topRightRadius=&quot;5dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:bottom=&quot;5dp&quot; android:left=&quot;5dp&quot; android:right=&quot;5dp&quot; android:top=&quot;5dp&quot; /&gt; &lt;/shape&gt; button.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; android:padding=&quot;10dp&quot; &gt; &lt;Button android:id=&quot;@+id/wangdaileiBtn&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;40dp&quot; android:layout_weight=&quot;1&quot; android:scaleType=&quot;fitXY&quot; android:text=&quot;&quot; android:background=&quot;@drawable/switch_button_left_checked&quot; /&gt; &lt;Button android:id=&quot;@+id/baobaoleiBtn&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;40dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;&quot; android:scaleType=&quot;fitXY&quot; android:background=&quot;@drawable/switch_button_right&quot; /&gt; &lt;/LinearLayout&gt;","categories":[{"name":"Android笔记","slug":"Android笔记","permalink":"http://logan62334.github.io/categories/Android笔记/"}],"tags":[{"name":"Android布局UI","slug":"Android布局UI","permalink":"http://logan62334.github.io/tags/Android布局UI/"}]}]}